Erste Strategie:

Jeder Stich läßt sich in verschiedene Kategorien einordnen:
Farbstich
Trumpfstich
Linker
Rechter
Guater
Nach jedem Stich wird der Reihe nach getestet ob dies ein Farbstich, usw. ist.

Erste Klassen, die unsere Daten aufnehemen sollen:

public class Card {
	public int color;
	public int number;

	public Card(int color, int number) {
		this.color = color;
		this.number = number;
	}
}

public class CONSTANTS {
	final static int EICHEL = 0;
	final static int HERZ = 1;
	final static int LAUB = 2;
	final static int SCHELL = 3;
	
	final static int SECHSER = 6;
	final static int SIEBNER = SECHSER + 1;
	final static int ACHTER = SECHSER + 2;
	final static int NEUNER = SECHSER + 3;
	final static int ZEHNER = SECHSER + 4;
	final static int UNTER = SECHSER + 5;
	final static int OBER = SECHSER + 6;
	final static int KOENIG = SECHSER + 7;
	final static int AS = SECHSER + 8;
}

public class Stich {
	public Card[] cards;
	public int winner;
	
	public Stich(Card card1, Card card2, Card card3, Card card4, int winner) {
		cards = new Card[4];
		cards[0] = card1;
		cards[1] = card2;
		cards[2] = card3;
		cards[3] = card4;
		this.winner = winner;
	}
}

Nach den ersten Datenklassen erfolgt nun der erste Test, denn die Strategie Farbstich müsste sich recht einfach implementieren und testen lassen.

public class Farbstich {
	public int isFarbstich(Stich stich) {
		if(stich.cards[0].color == stich.cards[stich.winner].color 
		&& stich.cards[0].number < stich.cards[stich.winner].number)
			return CONSTANTS.POSSIBLE;
		return CONSTANTS.IMPOSSIBLE;
	}
}

CONSTANTS.java muss dann um folgende Konstanten ergänzt werden:
	final static int IMPOSSIBLE = -1;
	final static int POSSIBLE = 0;
	final static int SURE = 1;

Klasse Farbstich mit nur einer Methode isFarbstich() in Klasse Result umbenannt, die alle Tests aufnehmen soll.

Obige Klasse wird nun gleich getestet:

import junit.framework.TestCase;

public class SticheTest extends TestCase {
	
	Card herzAs;
	Card herzKoenig;
	Card herz10;
	Card schellAs;
	Card schellKoenig;
	Stich stich0, stich1, stich2, stich3, stich4;

	
	public void setUp() {
		herzAs = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		herzKoenig = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		schellAs = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		schellKoenig = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		herz10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		stich0 = new Stich(herzKoenig,schellKoenig,schellAs,herzAs,0);
		stich1 = new Stich(herzKoenig,schellKoenig,schellAs,herzAs,1);
		stich2 = new Stich(herzKoenig,schellKoenig,schellAs,herzAs,2);
		stich3 = new Stich(herzKoenig,schellKoenig,schellAs,herzAs,3);
		stich4 = new Stich(herz10,schellKoenig,herzKoenig,herzAs,2);
	}
	
	public void test_isFarbstich() {
		Result result = new Result();
		assertEquals(CONSTANTS.IMPOSSIBLE,new Result().isFarbstich(stich0));
		assertEquals(CONSTANTS.IMPOSSIBLE,new Result().isFarbstich(stich1));
		assertEquals(CONSTANTS.IMPOSSIBLE,new Result().isFarbstich(stich2));
		assertEquals(CONSTANTS.POSSIBLE,new Result().isFarbstich(stich3));
		assertEquals(CONSTANTS.IMPOSSIBLE,new Result().isFarbstich(stich4));
	}
}

Oh je! Fehler in der Funktion isFarbstich(). Stich4 zeigt, dass es nicht ausreicht
nur die erste Karte und den winner zu testen, da ja noch eine höhere Karte mit
gleicher Farbe wie der winner im Stich sein könnte.
isFarbstich() muss komplett umgeschrieben werden.

daher neue Version:

public class Result {
	
	public int isFarbstich(Stich stich) {
		// Farbe muss auf alle Fälle stimmen
		if(stich.cards[0].color != stich.cards[stich.winner].color)
			return CONSTANTS.IMPOSSIBLE;
		// Winner muss die höchste Karte seiner Farbe im Stich sein
		boolean isHoechsteFarbkarte = true;
		for(Card card : stich.cards) 
			isHoechsteFarbkarte = isHoechsteFarbkarte && card.number <= stich.cards[stich.winner].number;
		if(isHoechsteFarbkarte)
			return CONSTANTS.POSSIBLE;
		return CONSTANTS.IMPOSSIBLE;
	}
}

und gleich wieder testen!

Zusätzliche Information, die aus dem möglichen Farbstich gewonnen werden kann,
soll in Result gespeichert werden.
z.B.: die Nummer aller nicht-winner Karten kann kein Schlag sein!

Die Schläge können als int Array mit den Werten IMPOSSIBLE, POSSIBLE und SURE
in Result abgespeichert werden.
Die Kartennummer ließe sich gut als Index verwenden, wenn sie bei 0 starten würde.
Also ändern wir in CONSTANTS

	final static int SECHSER = 0;
	
Die Klasse Result erweitert sich daher wie folgt:

public class Result {
	
	public int[] schlag;
	
	public Result() {
		schlag = new int[CONSTANTS.AS + 1];  // alle automatisch auf 0 = POSSIBLE!
	}
	
	public int isFarbstich(Stich stich) {
		// Farbe muss auf alle Fälle stimmen
		if(stich.cards[0].color != stich.cards[stich.winner].color)
			return CONSTANTS.IMPOSSIBLE;
		// Winner muss die höchste Karte seiner Farbe im Stich sein
		boolean isHoechsteFarbkarte = true;
		for(Card card : stich.cards) {
			isHoechsteFarbkarte = isHoechsteFarbkarte && card.number <= stich.cards[stich.winner].number;
			if(card.number != stich.cards[stich.winner].number)
				schlag[card.number] = CONSTANTS.IMPOSSIBLE;
		}
		if(isHoechsteFarbkarte)
			return CONSTANTS.POSSIBLE;
		return CONSTANTS.IMPOSSIBLE;
	}
}

Nun sollten wir auch unsere Schläge in schlag testen.

	public void test_isFarbstich() {
		Result result = new Result();
		int[] nichtAs = {0,0,0,0,0,0,0,0,-1};
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich0));
	
		for(int i = 0; i < nichtAs.length; i++)
			assertEquals(nichtAs[i],result.schlag[i]);
		
		result = new Result();
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich1));
		for(int i = 0; i < nichtAs.length; i++)
			assertEquals(nichtAs[i],result.schlag[i]);
		
		result = new Result();
		int[] nichtKoenig = {0,0,0,0,0,0,0,-1,0};
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich2));
		for(int i = 0; i < nichtAs.length; i++)
			assertEquals(nichtKoenig[i],result.schlag[i]);
		
		result = new Result();
		assertEquals(CONSTANTS.POSSIBLE,result.isFarbstich(stich3));
		for(int i = 0; i < nichtAs.length; i++)
			assertEquals(nichtKoenig[i],result.schlag[i]);
		
		result = new Result();
		int[] nicht10_As = {0,0,0,0,-1,0,0,0,-1};
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich4));
		for(int i = 0; i < nichtAs.length; i++)
			assertEquals(nichtAs[i],result.schlag[i]);
	}
}

Das umschreiben führt aber zum Problem, dass in isFarbstich() nicht jeder Fall zum
Durchlauf jenes Teiles der den Schlag setzt, führt.

Idee unmögliche Schläge aussortieren als eigene Strategie:
unmögliche Schläge aussortiern
Farbstich
Trumpfstich
Linker
Rechter
Guater

Das Klasse Result wird nun übersichtlicher:

public class Result {
	
	public int[] schlag;
	
	public Result() {
		schlag = new int[CONSTANTS.AS + 1];  // alle automatisch auf 0 = POSSIBLE!
	}
	
	public void dropSchlag(Stich stich) {
		for(Card card : stich.cards) 
			if(card.number != stich.cards[stich.winner].number) 
				schlag[card.number] = CONSTANTS.IMPOSSIBLE;
	}
	
	public int isFarbstich(Stich stich) {
		// Farbe muss auf alle Fälle stimmen
		if(stich.cards[0].color != stich.cards[stich.winner].color)
			return CONSTANTS.IMPOSSIBLE;
		// Winner muss die höchste Karte seiner Farbe im Stich sein
		boolean isHoechsteFarbkarte = true;
		for(Card card : stich.cards) 
			isHoechsteFarbkarte = isHoechsteFarbkarte && card.number <= stich.cards[stich.winner].number;
		if(isHoechsteFarbkarte)
			return CONSTANTS.POSSIBLE;
		return CONSTANTS.IMPOSSIBLE;
	}
}

auch die Testklasse gewinnt wieder an Übersichtlichkeit:

public void test_dropSchlag() {
		int[] nichtAs = {0,0,0,0,0,0,0,0,-1};
		Result result = new Result();
		result.dropSchlag(stich0);
		for(int i = 0; i < nichtAs.length; i++)
			assertEquals(nichtAs[i],result.schlag[i]);
	
		result = new Result();
		result.dropSchlag(stich1);
		for(int i = 0; i < nichtAs.length; i++)
			assertEquals(nichtAs[i],result.schlag[i]);
		
		int[] nichtKoenig = {0,0,0,0,0,0,0,-1,0};
		result = new Result();
		result.dropSchlag(stich2);
		for(int i = 0; i < nichtKoenig.length; i++)
			assertEquals(nichtKoenig[i],result.schlag[i]);
		
		result = new Result();
		result.dropSchlag(stich3);
		for(int i = 0; i < nichtKoenig.length; i++)
			assertEquals(nichtKoenig[i],result.schlag[i]);
		
		result = new Result();
		int[] nicht10_As = {0,0,0,0,-1,0,0,0,-1};
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich4));
		for(int i = 0; i < nicht10_As.length; i++)
			assertEquals(nicht10_As[i],result.schlag[i]);
	}
	
	public void test_isFarbstich() {
		Result result = new Result();
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich0));
		
		result = new Result();
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich1));
	
		result = new Result();
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich2));
	
		result = new Result();
		assertEquals(CONSTANTS.POSSIBLE,result.isFarbstich(stich3));
		
		result = new Result();
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich4));
	}
}

Da in dropSchlag() der Guate nicht noch nicht berücksichtig wurde, wollen wir ihn
jetzt einbauen. Optimal wäre es, Result in der Variation "mit Guatem" und "ohne Guatem"
starten zu können.
Result wird deshalb um die Variable boolean mitGuatem erweitert. Die Spielart soll im
Konstruktor angepasst werden.

public class Result {	
	
	private boolean mitGuatem;
	private int[] schlag;
	
	public Result(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		schlag = new int[CONSTANTS.AS + 1];  // alle automatisch auf 0 = POSSIBLE!
	}
	
In der Klasse ResultTest.java müssen nun die Aufrufe von Result() in Result(false)
geändert und getestet! werden!

Wenn das geklappt hat, können wir dropSchlag entsprechend anpassen.

	public void dropSchlag(Stich stich) {
		for(Card card : stich.cards) 
			if(card.number != stich.cards[stich.winner].number ||
			   (mitGuatem && card.number != stich.cards[stich.winner].number - 1))
				schlag[card.number] = CONSTANTS.IMPOSSIBLE; 
	}
	
und testen der alten Fälle!

Auch wenn der Fall, dass der Veli der Guate ist noch nicht berücksichtig ist, bauen 
wir neue Testfälle ein:
Die Testmethode public void test_dropSchlag() wird dazu in 
public void test_dropSchlag_ohne_Guatem() umbenannt.
public void test_dropSchlag_mit_Guatem() wird neu hinzugefügt.

Die Namensgebung dropSchlag() erscheint uns eigentlich nicht günstig:
setImpossibleSchlag() erscheint viel günstiger, sodass nach einer Umbennenung
folgend Situation vorliegt:

public class Result {
	
	boolean mitGuatem;
	public int[] schlag;
	
	public Result(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		schlag = new int[CONSTANTS.AS + 1];  // alle automatisch auf 0 = POSSIBLE!
	}
	
	public void setImpossibleSchlag(Stich stich) {
		for(Card card : stich.cards) 
			if(!((card.number == stich.cards[stich.winner].number) ||
			  (mitGuatem && card.number == stich.cards[stich.winner].number - 1)))
				schlag[card.number] = CONSTANTS.IMPOSSIBLE; 
	}
	
	public int isFarbstich(Stich stich) {
		// Farbe muss auf alle Fälle stimmen
		if(stich.cards[0].color != stich.cards[stich.winner].color)
			return CONSTANTS.IMPOSSIBLE;
		// Winner muss die höchste Karte seiner Farbe im Stich sein
		boolean isHoechsteFarbkarte = true;
		for(Card card : stich.cards) 
			isHoechsteFarbkarte = isHoechsteFarbkarte && card.number <= stich.cards[stich.winner].number;
		if(isHoechsteFarbkarte)
			return CONSTANTS.POSSIBLE;
		return CONSTANTS.IMPOSSIBLE;
	}
}


public class ResultTest extends TestCase {
	
	Card herzAs, herzKoenig, herz10, herz9, herz8, herz7;
	Card schellAs, schellKoenig, schell7;
	Stich stich0, stich1, stich2, stich3, stich4, stich5;
	Stich stich6, stich7, stich8, stich9, stich10, stich11;

	
	public void setUp() {
		herzAs = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		herzKoenig = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		herz10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		herz9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		herz8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		herz7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		schellAs = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		schellKoenig = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		schell7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		
		stich0 = new Stich(herzKoenig,schellKoenig,schellAs,herzAs,0);
		stich1 = new Stich(herzKoenig,schellKoenig,schellAs,herzAs,1);
		stich2 = new Stich(herzKoenig,schellKoenig,schellAs,herzAs,2);
		stich3 = new Stich(herzKoenig,schellKoenig,schellAs,herzAs,3);
		stich4 = new Stich(herz10,schellKoenig,herzKoenig,herzAs,2);
		stich5 = new Stich(herz10,schell7,herzKoenig,herzAs,2);
		stich6 = new Stich(herz7,herz8,herz9,herz10,3);
		stich7 = new Stich(herz7,herz8,herz9,herz10,2);
	}
	
	public void test_setImpossibleSchlag_without_Guater() {
		/*
		assertEquals(schlag[0],result.schlag[0]);
		assertEquals(schlag[1],result.schlag[1]);
		assertEquals(schlag[2],result.schlag[2]);
		assertEquals(schlag[3],result.schlag[3]);
		assertEquals(schlag[4],result.schlag[4]);
		assertEquals(schlag[5],result.schlag[5]);
		assertEquals(schlag[6],result.schlag[6]);
		assertEquals(schlag[7],result.schlag[7]);
		assertEquals(schlag[8],result.schlag[8]);
		*/
		
		int[] nichtAs = {0,0,0,0,0,0,0,0,-1};
		Result result = new Result(false);
		result.setImpossibleSchlag(stich0);
		for(int i = 0; i < nichtAs.length; i++)
			assertEquals(nichtAs[i],result.schlag[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(stich1);
		for(int i = 0; i < nichtAs.length; i++)
			assertEquals(nichtAs[i],result.schlag[i]);
		
		int[] nichtKoenig = {0,0,0,0,0,0,0,-1,0};
		result = new Result(false);
		result.setImpossibleSchlag(stich2);
		for(int i = 0; i < nichtKoenig.length; i++)
			assertEquals(nichtKoenig[i],result.schlag[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(stich3);
		for(int i = 0; i < nichtKoenig.length; i++)
			assertEquals(nichtKoenig[i],result.schlag[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(stich4);
		int[] nicht10_As = {0,0,0,0,-1,0,0,0,-1};
		assertEquals(nicht10_As[4],result.schlag[4]);
		for(int i = 0; i < nicht10_As.length; i++)
			assertEquals(nicht10_As[i],result.schlag[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(stich5);
		int[] nicht7_10_As = {0,-1,0,0,-1,0,0,0,-1};
		assertEquals(nicht10_As[4],result.schlag[4]);
		for(int i = 0; i < nicht7_10_As.length; i++)
			assertEquals(nicht7_10_As[i],result.schlag[i]);
	}
	
	public void test_setImpossibleSchlag_with_Guater() {
		int[] guaterAS = {0,0,0,0,0,0,0,0,0};
		Result result = new Result(true);
		result.setImpossibleSchlag(stich3);
		for(int i = 0; i < guaterAS.length; i++)
			assertEquals(guaterAS[i],result.schlag[i]);
		
		int[] guater10 = {0,-1,-1,0,0,0,0,0,0};
		result = new Result(true);
		result.setImpossibleSchlag(stich6);
		for(int i = 0; i < guater10.length; i++)
			assertEquals(guater10[i],result.schlag[i]);
		
		int[] guater9 = {0,-1,0,0,-1,0,0,0,0};
		result = new Result(true);
		result.setImpossibleSchlag(stich7);
		for(int i = 0; i < guater9.length; i++)
			assertEquals(guater9[i],result.schlag[i]);
	
	}

	
	public void test_isFarbstich() {
		Result result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich0));
		
		result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich1));
	
		result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich2));
	
		result = new Result(false);
		assertEquals(CONSTANTS.POSSIBLE,result.isFarbstich(stich3));
		
		result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isFarbstich(stich4));
	}
}

Das Testprogramm ist in seiner Handhabung zu sperrig. Die Definition der Stiche 
ist zu weit vom jeweiligen Einsatz entfernt.
ResultTest.java wird durch Test_Result.java ersetzt:

import junit.framework.TestCase;

public class Test_Result extends TestCase {
	
	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	
	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);
		
		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);
		
		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
	}
	
	public void test_setImpossibleSchlag_without_Guater() {
		
		Result result = new Result(false);
		result.setImpossibleSchlag(new Stich(hK,sK,sA,hA,0));
		int[] kingBeatsAs = {0,0,0,0,0,0,0,0,-1};
		for(int i = 0; i < kingBeatsAs.length; i++)
			assertEquals(kingBeatsAs[i],result.schlag[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(new Stich(hK,sK,sA,hA,1));
		for(int i = 0; i < kingBeatsAs.length; i++)
			assertEquals(kingBeatsAs[i],result.schlag[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(new Stich(hK,sK,sA,hA,2));
		int[] asBeatsKing = {0,0,0,0,0,0,0,-1,0};
		for(int i = 0; i < asBeatsKing.length; i++)
			assertEquals(asBeatsKing[i],result.schlag[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(new Stich(hK,sK,sA,hA,3));
		for(int i = 0; i < asBeatsKing.length; i++)
			assertEquals(asBeatsKing[i],result.schlag[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(new Stich(h10,sK,hK,hA,2));
		int[] kingBeats10AndAs = {0,0,0,0,-1,0,0,0,-1};
		assertEquals(kingBeats10AndAs[4],result.schlag[4]);
		for(int i = 0; i < kingBeats10AndAs.length; i++)
			assertEquals(kingBeats10AndAs[i],result.schlag[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(new Stich(h10,s7,hK,hA,2));
		int[] kingBeats7And10AndAs = {0,-1,0,0,-1,0,0,0,-1};
		assertEquals(kingBeats10AndAs[4],result.schlag[4]);
		for(int i = 0; i < kingBeats7And10AndAs.length; i++)
			assertEquals(kingBeats7And10AndAs[i],result.schlag[i]);
	}
	
	public void test_setImpossibleSchlag_with_Guater() {
		Result result = new Result(true);
		result.setImpossibleSchlag(new Stich(hK,sK,sA,hA,3));
		int[] guaterAS = {0,0,0,0,0,0,0,0,0};
		for(int i = 0; i < guaterAS.length; i++)
			assertEquals(guaterAS[i],result.schlag[i]);
		
		result = new Result(true);
		result.setImpossibleSchlag(new Stich(h7,h8,h9,h10,3));
		int[] guater10 = {0,-1,-1,0,0,0,0,0,0};
		for(int i = 0; i < guater10.length; i++)
			assertEquals(guater10[i],result.schlag[i]);
		
		int[] guater9 = {0,-1,0,0,-1,0,0,0,0};
		result = new Result(true);
		result.setImpossibleSchlag(new Stich(h7,h8,h9,h10,2));
		for(int i = 0; i < guater9.length; i++)
			assertEquals(guater9[i],result.schlag[i]);
	}

	
	public void test_isFarbstich() {
		Result result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,
				result.isFarbstich(new Stich(hK,sK,sA,hA,0)));
		
		result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,
				result.isFarbstich(new Stich(hK,sK,sA,hA,1)));
	
		result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,
				result.isFarbstich(new Stich(hK,sK,sA,hA,2)));
	
		result = new Result(false);
		assertEquals(CONSTANTS.POSSIBLE,
				result.isFarbstich(new Stich(hK,sK,sA,hA,3)));
		
		result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,
				result.isFarbstich(new Stich(h10,sK,hK,hA,2)));
	}
}

Beim Testen eines Farbstiches müsste man zuerst abfragen, ob nicht ein Trumpfstich
oder ein Schlagstich oder ein Guaterstich vorliegt.
Diese Abfrage legt eine gewisse Reihenfolge der Strategien fest. Zuerst wird nach einem 
Guaten, Rechten, Linken Stich gefragt, dann erst nach Trumpf bzw. Farbe.
Besonders einfach ist das Feststellen eines Guaten, Rechten, Linkenstiches, wenn
der Schlag und die Farbe bereits festtehen.
Wenn neben der Variable schlag[] noch eine Variable farbe[] festgelegt wird, kann
ein feststehender Schlag, oder eine feststehende Farbe leicht abgefragt werden.

Result.java ändert sich daher wie folgt:

public class Result {
	
	private boolean mitGuatem;
	private int[] schlag;
	private int[] farbe;
	
	
	public Result(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		schlag = new int[CONSTANTS.AS + 1];  // alle automatisch auf 0 = POSSIBLE!
		farbe = new int[CONSTANTS.SCHELL + 1];  // alle automatisch auf 0 = POSSIBLE!
	}
	
	public int[] getSchlag() { return schlag; }
	public int[] getFarbe() { return farbe; }
	
	public boolean isSchlagFix() {
		int numberOfSureSchlag = 0;
		for(int testedSchlag : schlag) if(testedSchlag == CONSTANTS.SURE) numberOfSureSchlag++;
		return (numberOfSureSchlag == 1);
	}
	
	public boolean isFarbeFix() {
		int numberOfSureFarbe = 0;
		for(int testedFarbe : farbe) if(testedFarbe == CONSTANTS.SURE) numberOfSureFarbe++;
		return (numberOfSureFarbe == 1);
	}
	
	public void setImpossibleSchlag(Stich stich) {
		for(Card card : stich.cards) 
			if(!((card.number == stich.cards[stich.winner].number) ||
			  (mitGuatem && card.number == stich.cards[stich.winner].number - 1)))
				schlag[card.number] = CONSTANTS.IMPOSSIBLE; 
	}
	
	public int isFarbstich(Stich stich) {
		// Farbe muss auf alle Fälle stimmen
		if(stich.cards[0].color != stich.cards[stich.winner].color)
			return CONSTANTS.IMPOSSIBLE;
		// Winner muss die höchste Karte seiner Farbe im Stich sein
		boolean isHoechsteFarbkarte = true;
		for(Card card : stich.cards) 
			isHoechsteFarbkarte = isHoechsteFarbkarte && card.number <= stich.cards[stich.winner].number;
		if(isHoechsteFarbkarte)
			return CONSTANTS.POSSIBLE;
		return CONSTANTS.IMPOSSIBLE;
	}
}

Im Rahmen dieser Änderung wurden die Variablen schlag und farbe auf private gesetzt
und mit get-Methoden versehen.
Dass sie dadurch nicht abgesichert sind zeigt der Zugriff auf result.schlag mittels
getSchlag() in Test_Result.java

public class Test_Result extends TestCase {
	
	...
	
	public void test_isSchlagFix() {
		Result result = new Result(false);
		int[] schlag = result.getSchlag();
		assertEquals(false,result.isSchlagFix());
		schlag[CONSTANTS.SECHSER] = schlag[CONSTANTS.SIEBNER] = CONSTANTS.IMPOSSIBLE;
		assertEquals(false,result.isSchlagFix());
		schlag[CONSTANTS.SECHSER] = CONSTANTS.SURE;
		assertEquals(true,result.isSchlagFix());
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		assertEquals(false,result.isSchlagFix());
		schlag[CONSTANTS.SECHSER] = CONSTANTS.IMPOSSIBLE;
		assertEquals(true,result.isSchlagFix());
	}
	
	public void test_isFarbeFix() {
		Result result = new Result(false);
		int[] farbe = result.getFarbe();
		assertEquals(false,result.isFarbeFix());
		farbe[1] = farbe[2] = CONSTANTS.IMPOSSIBLE;
		assertEquals(false,result.isFarbeFix());
		farbe[CONSTANTS.EICHEL] = CONSTANTS.SURE;
		assertEquals(true,result.isFarbeFix());
		farbe[CONSTANTS.HERZ] = CONSTANTS.SURE;
		assertEquals(false,result.isFarbeFix());
		farbe[CONSTANTS.EICHEL] = CONSTANTS.IMPOSSIBLE;
		assertEquals(true,result.isFarbeFix());
	}
	
	...
}

Im nächsten Schritt wollen wir Schlagstiche untersuchen:
Dazu stellen wir fest, dass es fein wäre den Schlag mittels getSchlag() abzufragen.
Dieser Name ist aber schon besetzt. getSchlag() wird daher sinnvollerweise in
getSchlagArray() und getFarbe() in getFarbeArray() umbenannt.

Beim Programmieren von getSchlag() fällt dann auf, dass das ganze Abfragen von
Schlägen und Farben höflich formuliert, als ziemlich durchwachsen erscheint.

private int getSchlag() {
		int position = 0;
		while(position < schlag.length && schlag[position] != CONSTANTS.SURE) 
			position++;
		return position;
	}
	
Hier muss dringend aufgeräumt werden!
Idee:
getSchlag() liefert CONSTANTS.IMPOSSIBLE wenn kein Schlag gefunden werden kann und
den Schlag sonst:

public int getSchlag() {
		int position = schlag.length - 1;
		System.out.println(position);
		while(position >= 0 && schlag[position] != CONSTANTS.SURE) 
			position--;
		return position;
	}

Das Abfragen des Array lässt sich dann weiters in eine Unterfunktion findFirstSURE(int[] array)
auslagern und auch für getFarbe() verwenden.
isSchlagFix() kann nun auf getSchlag() zurückgeführt oder ganz gestrichen werden.
hier die neuen Versionen:

public class Result {
	
	private boolean mitGuatem;
	private int[] schlag;
	private int[] farbe;
	
	
	public Result(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		schlag = new int[CONSTANTS.AS + 1];  // alle automatisch auf 0 = POSSIBLE!
		farbe = new int[CONSTANTS.SCHELL + 1];  // alle automatisch auf 0 = POSSIBLE!
	}
	
	public int[] getSchlagArray() { return schlag; }
	public int[] getFarbeArray() { return farbe; }
	
	public int getSchlag() {
		return findFirstSURE(schlag);
	}
	
	public int getFarbe() {
		return findFirstSURE(farbe);
	}
	
	private int findFirstSURE(int[] testArray) {
		int position = testArray.length - 1;
		while(position >= 0 && testArray[position] != CONSTANTS.SURE) 
			position--;
		return position;
	}
	
	public boolean isSchlagFix() {
		return getSchlag() != CONSTANTS.IMPOSSIBLE;
	}
	
	public boolean isFarbeFix() {
		return getFarbe() != CONSTANTS.IMPOSSIBLE;
	}
	...
	
		public void test_isSchlagFix_getSchlag() {
		Result result = new Result(false);
		int[] schlag = result.getSchlagArray();
		assertEquals(false,result.isSchlagFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getSchlag());
		
		schlag[CONSTANTS.SECHSER] = schlag[CONSTANTS.SIEBNER] = CONSTANTS.IMPOSSIBLE;
		assertEquals(false,result.isSchlagFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getSchlag());
		
		schlag[CONSTANTS.SECHSER] = CONSTANTS.SURE;
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.SECHSER,result.getSchlag());
		
		schlag[CONSTANTS.SECHSER] = CONSTANTS.IMPOSSIBLE;
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.AS,result.getSchlag());
	}
	
	public void test_isFarbeFix_getSchlag() {
		Result result = new Result(false);
		int[] farbe = result.getFarbeArray();
		assertEquals(false,result.isFarbeFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getFarbe());
		
		farbe[CONSTANTS.EICHEL] = farbe[CONSTANTS.HERZ] = CONSTANTS.IMPOSSIBLE;
		assertEquals(false,result.isFarbeFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getFarbe());
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.SURE;
		assertEquals(true,result.isFarbeFix());
		assertEquals(CONSTANTS.EICHEL,result.getFarbe());
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.IMPOSSIBLE;
		farbe[CONSTANTS.SCHELL] = CONSTANTS.SURE;
		assertEquals(true,result.isFarbeFix());
		assertEquals(CONSTANTS.SCHELL,result.getFarbe());
	}
	
Bei den Überlegungen zu den Test fällt auf, dass wenn 3 Farben ummöglich sind die 
4. Farbe die gesuchte sein muss.
Für die Funktion setImpossibleSchlag() bedeutet das, dass wenn alle bis auf einen Schlag
unmöglich sind, der über bleibende Schlag der gesuchte sein muss!
Das sollte in der Funktion angepasst werden. Wir verschieben das mal auf später; 
vielleicht wirds gar nicht gebraucht.
//testIfJustOnePossibleLeft(); wird zur Sicherheit in setImpossibleSchlag() vermerkt.

Die letzten Änderungen um Rechten und Guaten abzufragen, haben Änderungen in fast
allen Klassen bewirkt:

public class Card {
	public int color;
	public int number;
	
	public Card(int color, int number) {
		this.color = color;
		this.number = number;
	}
	
	public boolean equals(Card card) {
		return (card.color == this.color && card.number == this.number);
	}
}
 
wird um die Methode equals erweitert, um die Winnerkarte im Stich mit Guatem und 
Rechtem vergleichen zu können.

public class Stich {
	public Card[] cards;
	public int winner;
	
	public Stich(Card card1, Card card2, Card card3, Card card4, int winner) {
		cards = new Card[4];
		cards[0] = card1;
		cards[1] = card2;
		cards[2] = card3;
		cards[3] = card4;
		this.winner = winner;
	}
	
	public Card getWinner() {
		return cards[winner];
	}
}

Die Klasse Stich erhält eine Methode, um einfacher auf den Winner zugreifen zu können.

In der Klasse Result kann nun cards[stich.winner] durch stich.getWinner() ersetzt werden.
Außerdem werden die neuen get-Methoden eingebaut und dann natürlich auch getestet.

public class Result {
	
	private boolean mitGuatem;
	private int[] schlag;
	private int[] farbe;
	
	
	public Result(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		schlag = new int[CONSTANTS.AS + 1];  // alle automatisch auf 0 = POSSIBLE!
		farbe = new int[CONSTANTS.SCHELL + 1];  // alle automatisch auf 0 = POSSIBLE!
	}
	
	public int[] getSchlagArray() { return schlag; }
	public int[] getFarbeArray() { return farbe; }
	
	public int getSchlag() {
		return findFirstSURE(schlag);
	}
	
	public int getFarbe() {
		return findFirstSURE(farbe);
	}
	
	private int findFirstSURE(int[] testArray) {
		int position = testArray.length - 1;
		while(position >= 0 && testArray[position] != CONSTANTS.SURE) 
			position--;
		return position;
	}
	
	public boolean isSchlagFix() {
		return getSchlag() != CONSTANTS.IMPOSSIBLE;
	}
	
	public boolean isFarbeFix() {
		return getFarbe() != CONSTANTS.IMPOSSIBLE;
	}
	
	public boolean isRechterFix() {
		return (isSchlagFix() && isFarbeFix());
	}
	
	public boolean isGuaterFix() {
		return isRechterFix();
	}
	
	public Card getRechter() {
		return new Card(getFarbe(), getSchlag());
	}
	
	public Card getGuater() {
		int schlag = 0;
		schlag = (getSchlag() + 1)% (CONSTANTS.AS + 1);
		if(getFarbe() < CONSTANTS.SCHELL) schlag++;
		return new Card(getFarbe(), schlag);
	}
	
	public void setImpossibleSchlag(Stich stich) {
		for(Card card : stich.cards) 
			if(!((card.number == stich.cards[stich.winner].number) ||
			  (mitGuatem && card.number == stich.getWinner().number - 1)))
				this.schlag[card.number] = CONSTANTS.IMPOSSIBLE; 
		//testIfJustOnePossibleLeft();
	}
	
	public int isFarbstich(Stich stich) {
		// Farbe muss auf alle Fälle stimmen
		if(stich.cards[0].color != stich.getWinner().color)
			return CONSTANTS.IMPOSSIBLE;
		// Winner muss die höchste Karte seiner Farbe im Stich sein
		boolean isHoechsteFarbkarte = true;
		for(Card card : stich.cards) 
			isHoechsteFarbkarte = isHoechsteFarbkarte && card.number <= stich.getWinner().number;
		if(isHoechsteFarbkarte)
			return CONSTANTS.POSSIBLE;
		return CONSTANTS.IMPOSSIBLE;
	}
}

Und hier unsere neue Testklasse:

public class Test_Result extends TestCase {
	
	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	
	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);
		
		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);
		
		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
	}
	
	public void test_isSchlagFix_getSchlag() {
		Result result = new Result(false);
		int[] schlag = result.getSchlagArray();
		assertEquals(false,result.isSchlagFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getSchlag());
		
		schlag[CONSTANTS.SECHSER] = schlag[CONSTANTS.SIEBNER] = CONSTANTS.IMPOSSIBLE;
		assertEquals(false,result.isSchlagFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getSchlag());
		
		schlag[CONSTANTS.SECHSER] = CONSTANTS.SURE;
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.SECHSER,result.getSchlag());
		
		schlag[CONSTANTS.SECHSER] = CONSTANTS.IMPOSSIBLE;
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.AS,result.getSchlag());
	}
	
	public void test_isFarbeFix_getSchlag() {
		Result result = new Result(false);
		int[] farbe = result.getFarbeArray();
		assertEquals(false,result.isFarbeFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getFarbe());
		
		farbe[CONSTANTS.EICHEL] = farbe[CONSTANTS.HERZ] = CONSTANTS.IMPOSSIBLE;
		assertEquals(false,result.isFarbeFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getFarbe());
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.SURE;
		assertEquals(true,result.isFarbeFix());
		assertEquals(CONSTANTS.EICHEL,result.getFarbe());
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.IMPOSSIBLE;
		farbe[CONSTANTS.SCHELL] = CONSTANTS.SURE;
		assertEquals(true,result.isFarbeFix());
		assertEquals(CONSTANTS.SCHELL,result.getFarbe());
	}
	
	public void test_isRechterFix() {
		Result result = new Result(false);
		int[] schlag = result.getSchlagArray();
		int[] farbe = result.getFarbeArray();
		assertEquals(false,result.isRechterFix());
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.SURE;
		assertEquals(false,result.isRechterFix());
		
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		assertEquals(true,result.isRechterFix());
	}
	
	public void test_getRechter() {
		Result result = new Result(false);
		int[] schlag = result.getSchlagArray();
		int[] farbe = result.getFarbeArray();
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.SURE;
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		Card rechter = new Card(CONSTANTS.EICHEL,CONSTANTS.AS);
		assertEquals(true,result.getRechter().equals(rechter));
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.IMPOSSIBLE;
		schlag[CONSTANTS.AS] = CONSTANTS.IMPOSSIBLE;
		farbe[CONSTANTS.SCHELL] = CONSTANTS.SURE;
		schlag[CONSTANTS.SECHSER] = CONSTANTS.SURE;
		rechter = new Card(CONSTANTS.SCHELL,CONSTANTS.SECHSER);
		assertEquals(true,result.getRechter().equals(rechter));
	}
	
	public void test_getGuater() {
		Result result = new Result(false);
		int[] schlag = result.getSchlagArray();
		int[] farbe = result.getFarbeArray();
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.SURE;
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		Card guater = new Card(CONSTANTS.EICHEL,CONSTANTS.SIEBNER);
		assertEquals(true,result.getGuater().equals(guater));
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.IMPOSSIBLE;
		schlag[CONSTANTS.AS] = CONSTANTS.IMPOSSIBLE;
		farbe[CONSTANTS.SCHELL] = CONSTANTS.SURE;
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		guater = new Card(CONSTANTS.SCHELL,CONSTANTS.SECHSER);
		assertEquals(true,result.getGuater().equals(guater));
	}
	
	public void test_setImpossibleSchlag_without_Guater() {
		
		Result result = new Result(false);
		result.setImpossibleSchlag(new Stich(hK,sK,sA,hA,0));
		int[] kingBeatsAs = {0,0,0,0,0,0,0,0,-1};
		for(int i = 0; i < kingBeatsAs.length; i++)
			assertEquals(kingBeatsAs[i],result.getSchlagArray()[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(new Stich(hK,sK,sA,hA,1));
		for(int i = 0; i < kingBeatsAs.length; i++)
			assertEquals(kingBeatsAs[i],result.getSchlagArray()[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(new Stich(hK,sK,sA,hA,2));
		int[] asBeatsKing = {0,0,0,0,0,0,0,-1,0};
		for(int i = 0; i < asBeatsKing.length; i++)
			assertEquals(asBeatsKing[i],result.getSchlagArray()[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(new Stich(hK,sK,sA,hA,3));
		for(int i = 0; i < asBeatsKing.length; i++)
			assertEquals(asBeatsKing[i],result.getSchlagArray()[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(new Stich(h10,sK,hK,hA,2));
		int[] kingBeats10AndAs = {0,0,0,0,-1,0,0,0,-1};
		assertEquals(kingBeats10AndAs[4],result.getSchlagArray()[4]);
		for(int i = 0; i < kingBeats10AndAs.length; i++)
			assertEquals(kingBeats10AndAs[i],result.getSchlagArray()[i]);
		
		result = new Result(false);
		result.setImpossibleSchlag(new Stich(h10,s7,hK,hA,2));
		int[] kingBeats7And10AndAs = {0,-1,0,0,-1,0,0,0,-1};
		assertEquals(kingBeats10AndAs[4],result.getSchlagArray()[4]);
		for(int i = 0; i < kingBeats7And10AndAs.length; i++)
			assertEquals(kingBeats7And10AndAs[i],result.getSchlagArray()[i]);
	}
	
	public void test_setImpossibleSchlag_with_Guater() {
		Result result = new Result(true);
		result.setImpossibleSchlag(new Stich(hK,sK,sA,hA,3));
		int[] guaterAS = {0,0,0,0,0,0,0,0,0};
		for(int i = 0; i < guaterAS.length; i++)
			assertEquals(guaterAS[i],result.getSchlagArray()[i]);
		
		result = new Result(true);
		result.setImpossibleSchlag(new Stich(h7,h8,h9,h10,3));
		int[] guater10 = {0,-1,-1,0,0,0,0,0,0};
		for(int i = 0; i < guater10.length; i++)
			assertEquals(guater10[i],result.getSchlagArray()[i]);
		
		int[] guater9 = {0,-1,0,0,-1,0,0,0,0};
		result = new Result(true);
		result.setImpossibleSchlag(new Stich(h7,h8,h9,h10,2));
		for(int i = 0; i < guater9.length; i++)
			assertEquals(guater9[i],result.getSchlagArray()[i]);
	}

	
	public void test_isFarbstich() {
		Result result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,
				result.isFarbstich(new Stich(hK,sK,sA,hA,0)));
		
		result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,
				result.isFarbstich(new Stich(hK,sK,sA,hA,1)));
	
		result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,
				result.isFarbstich(new Stich(hK,sK,sA,hA,2)));
	
		result = new Result(false);
		assertEquals(CONSTANTS.POSSIBLE,
				result.isFarbstich(new Stich(hK,sK,sA,hA,3)));
		
		result = new Result(false);
		assertEquals(CONSTANTS.IMPOSSIBLE,
				result.isFarbstich(new Stich(h10,sK,hK,hA,2)));
	}
}

Jetzt gehts endlich weiter mit den Strategien:
Der Test für einen Stich mit dem Guaten scheint noch leicht zu sein:

public int isGuaterStich(Stich stich) {
		// trivialer Fall: Guater ist bekannt	
		if(isGuaterFix() &&  stich.getWinner().equals(this.getGuater())) {
			messageString = CONSTANTS.messageStichMitGuatem;
			return CONSTANTS.SURE;
		}
		else return CONSTANTS.POSSIBLE;
	}
	
doch bereits beim Testen auf einen Stich mit dem Rechten gehts so richtig los:

 trivialer Fall: Rechter ist bekannt	
		if(isRechterFix() &&  stich.getWinner().equals(this.getRechter())) {
			messageString = CONSTANTS.messageStichMitRechtem;
			return CONSTANTS.SURE;
		}

ist der triviale Fall noch recht einfach, so ist hier zumindest ein weiterer Fall zu 
bedenken:
ist die nächsthöhere Karte des Winners auch noch im Stich, wäre das dann der Guate,
was ein Widerspruch zum Rechtenstich wäre.
Es muss daher abgefragt werden, ob sich diese Karte im Stich befindet. Dazu sind Änderungen
in 2 Klassen nötig:
Card soll uns den Nachfolger einer Karte liefern und Stich soll testen können, ob
sich eine bestimmte Karte im Stich befindet.
Den Code für eine Nachfolgekarte haben wir schon in getGuater() geschrieben. Diesen Code 
wollen wir nun nach Card.next() verschieben.

public class Card {
	public int color;
	public int number;
	
	public Card(int color, int number) {
		this.color = color;
		this.number = number;
	}
	
	public boolean equals(Card card) {
		return (card.color == this.color && card.number == this.number);
	}
	
	public Card next() {
		number = (number + 1) % (CONSTANTS.AS + 1);
		if(color < CONSTANTS.SCHELL) number++;
		return new Card(color, number);
	}
}

getGuater() wird nun einfacher:

	public Card getGuater() {
		return getRechter().next();
	}
	
public class Stich {
	public Card[] cards;
	public int winner;
	
	public Stich(Card card1, Card card2, Card card3, Card card4, int winner) {
		cards = new Card[4];
		cards[0] = card1;
		cards[1] = card2;
		cards[2] = card3;
		cards[3] = card4;
		this.winner = winner;
	}
	
	public Card getWinner() {
		return cards[winner];
	}
	
	public boolean findCard(Card card) {
		int position = 0;
		boolean cardFound = false;
		while(position < cards.length && !cardFound) {
			cardFound = cards[position].equals(card);
		}
		return cardFound;
	}
}

und die Testklasse dazu:

public class Test_Stich extends TestCase {
	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	
	public void setUp() {
		hA = 
		...
	}
	
	public void test_findCard() {
		Stich stich = new Stich(e7,e8,e9,e10,1);
		assertEquals(true, stich.findCard(e7));
		assertEquals(false, stich.findCard(h7));
		
	}
}

Eine weitere triviale Möglichkeit guate und rechte Stiche auszusortieren besteht darin,
zu überprüfen, ob der dazugehörige Rechte bereits vorher aus der schlag[] Liste aussortiert 
wurde.
Dazu benötigen wir eine Methode getPreviousCard() in der Klasse Card.

Zum Testen der Linken benötigen wir weiters eine Methode nextColorCard() die uns die nächsten 
Karten der selben Nummer aber verschiedener Farbe liefert.

Beim Testen der Methode nextColorCard() wurde der Fehler bemerkt, dass 

public class Card {
	public int color;
	public int number;
	
	public Card(int color, int number) {
		this.color = color;
		this.number = number;
	}
	
	public boolean equals(Card card) {
		return (card.color == this.color && card.number == this.number);
	}
	
	public Card getNextNumberCard() {
		int number = this.number;
		number = (number + 1) % (CONSTANTS.AS + 1);
		if(color < CONSTANTS.SCHELL && number == CONSTANTS.SECHSER) number++;
		return new Card(color, number);
	}
	
	public Card getPreviousNumberCard() {
		int number = this.number;
		number = (number - 1 + CONSTANTS.AS + 1) % (CONSTANTS.AS + 1);
		if(color < CONSTANTS.SCHELL && number == CONSTANTS.SECHSER) number = CONSTANTS.AS;
		return new Card(color, number);
	}
	
	public Card nextColorCard() {
		int color = this.color;
		color = (color + 1) % (CONSTANTS.SCHELL + 1);
		return new Card(color, number);
	}
}

int number und int color !müssen! lokal sein. Ohne int davor werden die Daten des Objektes
selbst verändert. Scheisse!!! Ganz schwer zu finden. Daher werden wir den Namen dieser
Variablen gleich in newNumber und newColor verbessern!

Und endlich gehts wieder bei den Strategien weiter:
Sollte eine Karte bereits vorher als unmöglicher Rechter gekennzeichnet sein, oder sollte 
ihre Vorgängerkarte als unmöglicher Rechter gekennzeichnet sein, dann kann sie kein Guater sein!

public int isGuaterStich(Stich stich) {
		// trivialer Fall 1: Guater ist bekannt	
		if(isGuaterFix() &&  stich.getWinner().equals(this.getGuater())) {
			messageString += CONSTANTS.messageStichMitGuatemSURE;
			return CONSTANTS.SURE;
		}
		// trivialer Fall 2: Karte oder Vorgängerkarte in schlag[] auf IMPOSSIBLE
		else if(schlag[stich.getWinner().number] == CONSTANTS.IMPOSSIBLE ||
				schlag[stich.getWinner().getPreviousNumberCard().number] == CONSTANTS.IMPOSSIBLE) { 
			messageString += CONSTANTS.messageStichMitGuatemIMPOSSIBLE;
			return CONSTANTS.IMPOSSIBLE;
	} 
		else {
			messageString += CONSTANTS.messageStichMitGuatemPOSSIBLE;
			return CONSTANTS.POSSIBLE;
		}
	}	
	
und gleich wieder testen:

	public void test_isGuaterStich() {
		Result result = new Result(true);
		int[] schlag = result.getSchlagArray();
		int[] farbe = result.getFarbeArray();
		// nichts ist bekannt
		assertEquals(CONSTANTS.POSSIBLE,result.isGuaterStich(new Stich(s7,s8,h10,lO,2)));
		
		// schag der Vorgängerkarte ist IMPOSSIBLE
		schlag[CONSTANTS.SIEBNER] = CONSTANTS.IMPOSSIBLE; 
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isGuaterStich(new Stich(s7,s8,h10,lO,1)));
		
		// schag der Karte und der Vorgängerkarte ist IMPOSSIBLE
		schlag[CONSTANTS.SIEBNER] = CONSTANTS.IMPOSSIBLE; 
		schlag[CONSTANTS.ACHTER] = CONSTANTS.IMPOSSIBLE; 
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isGuaterStich(new Stich(s7,s8,h10,lO,1)));
		
		// schag der Karte ist IMPOSSIBLE
		schlag[CONSTANTS.SIEBNER] = CONSTANTS.POSSIBLE; 
		schlag[CONSTANTS.ACHTER] = CONSTANTS.IMPOSSIBLE; 
		assertEquals(CONSTANTS.IMPOSSIBLE,result.isGuaterStich(new Stich(s7,s8,h10,lO,1)));
		
		// Rechter ist bekannt
		schlag[CONSTANTS.NEUNER] = CONSTANTS.SURE; 
		farbe[CONSTANTS.HERZ] = CONSTANTS.SURE; 
		assertEquals(CONSTANTS.SURE,result.isGuaterStich(new Stich(s7,s8,h10,lO,2)));
	}

und für den Rechten:

public int isRechterStich(Stich stich) {
		// trivialer Fall 1: Rechter ist bekannt	
		if(isRechterFix() &&  stich.getWinner().equals(this.getRechter())) {
			messageString += CONSTANTS.messageStichMitRechtemSURE;
			return CONSTANTS.SURE;
		}
		// trivialer Fall 2: Karte in schlag[] auf IMPOSSIBLE
		else if(schlag[stich.getWinner().number] == CONSTANTS.IMPOSSIBLE) { 
			messageString += CONSTANTS.messageStichMitRechtemIMPOSSIBLE;
			return CONSTANTS.IMPOSSIBLE;
		} 
		// Fall 3: falls Rechter, dann wäre der Guate im Stich
		else if(stich.findCard(stich.getWinner().getNextNumberCard())) {
			messageString += CONSTANTS.messageStichMitRechtemIMPOSSIBLE;
			messageString += CONSTANTS.messagePossibleGuaterImStich;
			return CONSTANTS.IMPOSSIBLE;
		}
		else
			return CONSTANTS.POSSIBLE;
	}

und auch gleich wieder testen:

public int isRechterStich(Stich stich) {
		// trivialer Fall 1: Rechter ist bekannt	
		if(isRechterFix() &&  stich.getWinner().equals(this.getRechter())) {
			messageString += CONSTANTS.messageStichMitRechtemSURE;
			return CONSTANTS.SURE;
		}
		// trivialer Fall 2: Karte in schlag[] auf IMPOSSIBLE
		else if(schlag[stich.getWinner().number] == CONSTANTS.IMPOSSIBLE) { 
			messageString += CONSTANTS.messageStichMitRechtemIMPOSSIBLE;
			return CONSTANTS.IMPOSSIBLE;
		} 
		// Fall 3: falls Rechter, dann wäre der Guate im Stich
		else if(stich.findCard(stich.getWinner().getNextNumberCard())) {
			messageString += CONSTANTS.messageStichMitRechtemIMPOSSIBLE;
			messageString += CONSTANTS.messagePossibleGuaterImStich;
			return CONSTANTS.IMPOSSIBLE;
		}
		else
			return CONSTANTS.POSSIBLE;
	}
	
Oje, oje beim Testen von isRechterStich() "hängt" sich das Testmodul auf. Die Nachforschungen
zeigen, dass der Fehler in Fall 3 liegt. Nachdem das Testsystem in einer Endlosschleife verschwindet 
ist es naheliegend nach while() Schleife zu suchen. Diese finden wir in stich.findCard():

public boolean findCard(Card card) {
		int position = 0;
		boolean cardFound = false;
		while(position < cards.length && !cardFound) {
			cardFound = cards[position].equals(card);
		}
		return cardFound;
	}
	
und wirklich: Wo wird die position hochgezählt? :-(
Warum ist das beim Testen nicht aufgefallen:

public void test_findCard() {
		Stich stich = new Stich(e7,e8,e9,e10,1);
		assertEquals(true, stich.findCard(e7));
		assertEquals(false, stich.findCard(h7));
	}
	
Die Testdaten sind ganz misserabel gewählt! Es wird nur nach der ersten Karte gesucht!
Hier die neuen Testdaten:

public void test_findCard() {
		Stich stich = new Stich(e7,e8,e9,e10,1);
		assertEquals(true, stich.findCard(e7));
		assertEquals(false, stich.findCard(h7));
		assertEquals(true, stich.findCard(e10));
	}

und die neue Methode findCard():

public boolean findCard(Card card) {
		int position = 0;
		boolean cardFound = false;
		while(position < cards.length && !cardFound) {
			cardFound = cards[position].equals(card);
			position++;
		}
		return cardFound;
	} 


Nach dem Beheben dieser Fehler und den diesmal erfolgreichen Tests gehts weiter mit
isLinkerStich():

public int isLinkerStich(Stich stich) {
		// trivialer Fall : Rechter ist bekannt	
		if(isRechterFix() &&  stich.getWinner().number == this.getRechter().number) {
			messageString = CONSTANTS.messageStichMitLinkemSURE;
			return CONSTANTS.SURE;
		}
		else {
			messageString += CONSTANTS.messageStichMitLinkemPOSSIBLE;
			return CONSTANTS.POSSIBLE;
		}
	}
	
Wenn ein Linker bzw. ein Rechter im Stich nicht eindeutig festgestellt werden können, bleibt immer
noch die Möglichkeit eines allgemeinen Schlagstiches.
Daher wird weiter die Methode isSchlagStich() getestet:
Einen Schlagstich kann man sicher annehmen, wenn eine höhere Karte der selben Farbe im Stich vorhanden 
ist. Das legt eine Methode isWinnerColorBeated() in Stich nahe.

	public boolean isWinnerColorBeated() {
		int position = 0;
		boolean beat = false;
		while(position < cards.length && !beat) {
			beat = (cards[position].number > cards[winner].number) && (cards[position].color == cards[winner].color) ;
			position++;
		}
		return beat;
	}
}
 
und eingebaut in isSchlagStich():


	public int isSchlagStich(Stich stich) {
		if(isRechterStich(stich) == CONSTANTS.SURE ||
		   isLinkerStich(stich) == CONSTANTS.SURE) return CONSTANTS.SURE;
		else if(stich.isWinnerColorBeated()) {
			messageString += CONSTANTS.messageStichMitSchlagSURE;
			return CONSTANTS.SURE;
		} 
		else {
			messageString += CONSTANTS.messageStichMitSchlagPOSSIBLE;
			return CONSTANTS.POSSIBLE;
		}
			
	}

Wenn sich ein Schlagstich durch eine höhere Farbkarte feststellen lässt, dann lässt sich ein Stich
mit einem Linken durch einen Trumpf im Stich feststellen:

isLinkerStich() muss daher um diese Option angepasst werden:

	public int isLinkerStich(Stich stich) {
		...
		// Winner schlägt Trumpf
		else if(isTrumpfFix() && (stich.findColor(getTrumpf()))) {
			messageString += CONSTANTS.messageStichMitLinkemSURE;
			return CONSTANTS.SURE;
		...
	}
	 
wobei findColor() in stich wie folgt aussieht:

	public boolean findColor(int color) {
		int position = 0;
		boolean colorFound = false;
		while(position < cards.length && !colorFound) {
			colorFound = cards[position].color == color;
			position++;
		}
		return colorFound;
	}

Die Eigenschaft Farbe wurde in Result wurde in die sinnvollere Bezeichnung Trumpf umgewandelt:

public class Result {
	
	private boolean mitGuatem;
	private int[] schlag;
	private int[] trumpf;
	private String messageString;
	
	public Result(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		schlag = new int[CONSTANTS.AS + 1];  // alle automatisch auf 0 = POSSIBLE!
		trumpf = new int[CONSTANTS.SCHELL + 1];  // alle automatisch auf 0 = POSSIBLE!
	}
	
	// für die Testklassen
	public int[] getSchlagArray() { return schlag; }
	public int[] getFarbeArray() { return trumpf; }
	
	public int getSchlag() {
		return findFirstSURE(schlag);
	}
	
	public int getTrumpf() {
		return findFirstSURE(trumpf);
	}
	
	private int findFirstSURE(int[] testArray) {
		int position = testArray.length - 1;
		while(position >= 0 && testArray[position] != CONSTANTS.SURE) 
			position--;
		return position;
	}
	
	public boolean isSchlagFix() {
		return getSchlag() != CONSTANTS.IMPOSSIBLE;
	}
	
	public boolean isTrumpfFix() {
		return getTrumpf() != CONSTANTS.IMPOSSIBLE;
	}
	
	public boolean isRechterFix() {
		return (isSchlagFix() && isTrumpfFix());
	}
	
	public boolean isGuaterFix() {
		return isRechterFix();
	}
	
	public Card getRechter() {
		return new Card(getTrumpf(), getSchlag());
	}
	
	public Card getGuater() {
		return getRechter().getNextNumberCard();
	}
	
	public void calcSchlag(Stich stich) {
		for(Card card : stich.cards) 
			if(!((card.number == stich.cards[stich.winner].number) ||
			  (mitGuatem && card.number == stich.getWinner().number - 1)))
				this.schlag[card.number] = CONSTANTS.IMPOSSIBLE; 
		//testIfJustOnePossibleLeft();
	}
	
	public int isGuaterStich(Stich stich) {
		// trivialer Fall 1: Guater ist bekannt	
		if(isGuaterFix() &&  stich.getWinner().equals(this.getGuater())) {
			messageString += CONSTANTS.messageStichMitGuatemSURE;
			return CONSTANTS.SURE;
		}
		// trivialer Fall 2: Karte oder Vorgängerkarte in schlag[] auf IMPOSSIBLE
		else if(schlag[stich.getWinner().number] == CONSTANTS.IMPOSSIBLE ||
				schlag[stich.getWinner().getPreviousNumberCard().number] == CONSTANTS.IMPOSSIBLE) { 
			messageString += CONSTANTS.messageStichMitGuatemIMPOSSIBLE;
			return CONSTANTS.IMPOSSIBLE;
	} 
		else {
			messageString += CONSTANTS.messageStichMitGuatemPOSSIBLE;
			return CONSTANTS.POSSIBLE;
		}
	}
	
	public int isRechterStich(Stich stich) {
		// trivialer Fall 1: Rechter ist bekannt	
		if(isRechterFix() &&  stich.getWinner().equals(this.getRechter())) {
			messageString += CONSTANTS.messageStichMitRechtemSURE;
			return CONSTANTS.SURE;
		}
		// trivialer Fall 2: Karte in schlag[] auf IMPOSSIBLE
		else if(schlag[stich.getWinner().number] == CONSTANTS.IMPOSSIBLE) { 
			messageString += CONSTANTS.messageStichMitRechtemIMPOSSIBLE;
			return CONSTANTS.IMPOSSIBLE;
		} 
		// Fall 3: falls Rechter, dann wäre der Guate im Stich
		else if(stich.findCard(stich.getWinner().getNextNumberCard())) {
			messageString += CONSTANTS.messageStichMitRechtemIMPOSSIBLE;
			messageString += CONSTANTS.messagePossibleGuaterImStich;
			return CONSTANTS.IMPOSSIBLE;
		}
		else {
			messageString += CONSTANTS.messageStichMitRechtemPOSSIBLE;
			return CONSTANTS.POSSIBLE;
		}
	}
	
	public int isLinkerStich(Stich stich) {
		// trivialer Fall 1: Rechter ist bekannt	
		if(isRechterFix() &&  stich.getWinner().number == this.getRechter().number) {
			messageString = CONSTANTS.messageStichMitLinkemSURE;
			return CONSTANTS.SURE;
		}
		// trivialer Fall 2: Karte in schlag[] auf IMPOSSIBLE
		else if(schlag[stich.getWinner().number] == CONSTANTS.IMPOSSIBLE) { 
			messageString += CONSTANTS.messageStichMitLinkemIMPOSSIBLE;
			return CONSTANTS.IMPOSSIBLE;
		}
		// Winner schlägt Trumpf
		else if(isTrumpfFix() && (stich.findColor(getTrumpf()))) {
			messageString += CONSTANTS.messageStichMitLinkemSURE;
			return CONSTANTS.SURE;
		} 
		else {
			messageString += CONSTANTS.messageStichMitLinkemPOSSIBLE;
			return CONSTANTS.POSSIBLE;
		}
	}
	
	public int isSchlagStich(Stich stich) {
		if(isRechterStich(stich) == CONSTANTS.SURE ||
		   isLinkerStich(stich) == CONSTANTS.SURE) return CONSTANTS.SURE;
		else if(stich.isWinnerColorBeated()) {
			messageString += CONSTANTS.messageStichMitSchlagSURE;
			return CONSTANTS.SURE;
		} 
		else {
			messageString += CONSTANTS.messageStichMitSchlagPOSSIBLE;
			return CONSTANTS.POSSIBLE;
		}
			
	}


	public int isFarbstich(Stich stich) {
		// Farbe muss auf alle Fälle stimmen
		if(stich.cards[0].color != stich.getWinner().color)
			return CONSTANTS.IMPOSSIBLE;
		// Winner muss die höchste Karte seiner Farbe im Stich sein
		boolean isHoechsteFarbkarte = true;
		for(Card card : stich.cards) 
			isHoechsteFarbkarte = isHoechsteFarbkarte && card.number <= stich.getWinner().number;
		if(isHoechsteFarbkarte)
			return CONSTANTS.POSSIBLE;
		return CONSTANTS.IMPOSSIBLE;
	}
}

Bei nachfolgenden Überlegungen wurde jetzt auch noch dieser Fehler entdeckt:
Ein Guater lässt sich nicht ausschliessen, wenn sein Schlag auf IMPOSSIBLE gesetzt ist. Das muss in 
der Methode isGuaterStich() und im dazugehörigen Test berichtigt werden:

	else if(schlag[stich.getWinner().getPreviousNumberCard().number] == CONSTANTS.IMPOSSIBLE) { 
			messageString += CONSTANTS.messageStichMitGuatemIMPOSSIBLE;
			return CONSTANTS.IMPOSSIBLE;
		} 
		
		// schag der Karte ist IMPOSSIBLE
		schlag[CONSTANTS.SIEBNER] = CONSTANTS.POSSIBLE; 
		schlag[CONSTANTS.ACHTER] = CONSTANTS.IMPOSSIBLE; 
		assertEquals(CONSTANTS.POSSIBLE,result.isGuaterStich(new Stich(s7,s8,h10,lO,1)));
		

Weitere Probleme in isSchlagStich() entdeckt:
Mehrfaches Aufrufen von isRechterStich() und isGuaterStich() führen zu mehrfachen Aneinanderreihung
der immer gleichen messages!  Oh, weia! Zeit für eine Pause!!! Da ist der Wurm drinnen!

public int isSchlagStich(Stich stich) {
		if(isRechterStich(stich) == CONSTANTS.SURE ||
		   isLinkerStich(stich) == CONSTANTS.SURE) return CONSTANTS.SURE;


Überlegungen:

Leider scheint es nun so, dass die zu untersuchenden Fälle in isRechterStich() und isLinkerStich() 
beginnen sehr unübersichtlich zu sein. Vor allem da Fälle wie winner als 1. Karte kann von späterer 
höheren Farb oder Trumpfkarte nicht geschlagen werden.
Die 2. Idee zuerst auf Guaten, dann auf auf Rechten, Linken, Schlag usw. zu prüfen scheint sich so 
nicht sauber verwirklichen zu lassen.
Wenn man eine Ausgabe der Form:

Guater Stich: möglich
Rechter Stich: möglich
Linker Stich: möglich
Schlag Stich: sicher
Trumpfstich: unmöglich
Farbstich: unmöglich

haben will, dann muss das Zusammenwirken der einzelnen Strategien koordiniert werden.

Ideesammlung:(wäre früher wahrscheinlich besser gewesen!)

kein Vorwissen:				Schlag		Linker		Rechter		Guater		Trumpf			
Stich						0			0			0			0			0
Farbstich					0			0			0			0			0		
w=1 < farbkarte				1			0			0			0			0
w!=1 < farbkarte			1			0			0			0			0
w + 3 andere Farben			0			0			0			0			0
w & w+1						0			0			-1			0			0

so wie es hier aussieht, lassen sich nur folgende Regeln sinnvoll verwerten:

kein Vorwissen:				Schlag		Linker		Rechter		Guater		Trumpf		Farbe		
w < farbkarte				1			0			0			0			0			0
w & w+1						1			1			-1			0			-1			1

schlag=-1:					Schlag		Linker		Rechter		Guater		Trumpf		Farbe	
w!=1															0			1			-1
w!=1 < farbkarte0												1			1			-1

trumpf=-1:					Schlag		Linker		Rechter		Guater		Trumpf																				
w!=1 farbe!=1				1			1			
w!=1 w<farbkarte1			1			1			
w!=1 w>farbkarte			0			0												


schlag=-1 & schlag-1=-1:	Schlag		Linker		Rechter		Guater		Trumpf			
w=1 & 3 Farben																1
w!=1																		1


trumpf=-1 & schlag=-1:		Schlag		Linker		Rechter		Guater		Trumpf			
w							

****************************************************************************
Versuch einer Zusammenfassung wichtiger Regeln:

Regeln ohne Vorwissen: (Informationsgewinn!!)
---------------------------------------------
1. Alle Nummern != winner.number bzw. != winner.number-1 (bei Guatem) sind sicher keine Schläge.	
2. Befindet sich eine höhere Karte gleicher Farbe im Stich, dann ist der winner ein Schlag oder der Guate.
3. Befindet sich die nächsthöhere Karte des winners im Stich, dann ist der Winner ein Linker. 

Regeln zur Einteilung der Stiche:
---------------------------------
Regeln mit Vorwissen: winner != schlag
Dann kann der Stich nur ein Farbstich, Trumpfstich oder Guaterstich sein.

Regeln mit Vorwissen: winner == schlag
Dann kann der Stich nur ein Linkerstich oder Rechterstich sein.

Regeln mit Vorwissen: winner != trumpf
Dann kann der Stich nur ein Farbstich oder Linkerstich sein.

Regeln mit Vorwissen: winner == trumpf
Dann kann der Stich nur ein Trumpfstich, Rechterstich oder Guaterstich sein.

Regeln mit Vorwissen: winner != schlag && winner != trumpf
Dann kann der Stich nur ein Farbstich sein.

Regeln mit Vorwissen: winner == schlag && winner == trumpf
Dann kann der Stich nur ein Rechterstich sein.


****************************************************************************

Formulierung einer neuen Strategie: (Versuche am Zettel)

1. Für jeden Stich werden die Regeln ohne Vorwissen ausgewertet.
2. Bleiben noch etwas offen, wird eine Annahme getroffen und die früheren Stiche auf Grund dieser
   Annahme untersucht. z.B winner ist Guater, Rechter usw.
   Annahmen, die zu Widersprüchen führen, sind dann auszuschliessen.
   
Bsp:
Rechter: SK
HA(1) E9(2) E8(3) HO(4)	w=0		6	7	8-	9-	10	U	O-	K	A	:	E	H	L	S
dann: Widerspruch zu Guater, Rechter, Linker, Trumpf , Farbstich = nein
EO(1) H8(2) H9(3) S7(4) w=3 	6	7	8-	9-	10	U	O-	K	A	:	E	H	L	S~
dann: Widerspruch zu  Guater, Rechter, Linker und Trumpf = nein; Farbstich = ja => Trumpf oder Schlag (nicht verwertet!)
EU(4) SK(1) HU(2) LO(3) w=1		6	7	8-	9-	10	U-	O-	K	A	:	E	H	L	S+
dann: Widerspruch zu Rechter, Trumpf = nein; 
Guater(HO!=w) => O-, Linker(S7==Linker) => Trumpf

Verbesserung der neuen Strategie:
nur 1. Alle Nummern != winner.number bzw. != winner.number-1 (bei Guatem) sind sicher keine Schläge.
2. dann Regel der Reihe nach:
2.1: Guater- => schlag[Guater-1]-
2.2: Rechter- && Linker- && Farbstich- => Trumpf[]+
2.3: x & x+1 => Linker = Trumpf[]- & schlag[]+
2.4: Trumpf- && Farbstich- => Linker = schlag[]+

Vorteil: nach diesem Prinzip können neue Regeln einfach dazugefügt werden!!
 
 
und wieder viele Zettel später (hätte ganz an den Anfang gehört!!):

Arbeitsschritt 1:
Falls noch nötig sondiere unnötige Schläge aus.
Verwende dazu alle Stiche:
Bsp: Rechter=H8
EK	S7	HU	HO	w=3		6	7-	8	9	10	U	O	K-	A
H10 LO	S9	SA	w=0		6	7-	8	9	10	U-	O-	K-	A-
Begründung:	Unter wurde zuerst über den Ober, der möglicher Guater war gesperrt, da diese Sperre
	aufgehoben wurde, kann nun auch der Unter freigegeben werden.
Neubeurteilung des 1. Stiches nun möglich oder nötig?

Arbeitsschritt 2:
teste auf:
reinen Farbstich	FS 		T=-1 && S=-1
reiner Trumpfstich	TS		T=+1 && S=-1
reiner SchlagStich	SS		T=-1 && S=+1
reiner RechterStich	RS		T=+1 && S=+1
reiner GuaterStich	GS		T=+1 && S-1=+1

Arbeitsschritt 3:
schlussfolgere:
FS=-1 && SS=-1 => setze Farbe von w +1
TS=-1 && RS=-1 && GS=-1 => setze Farbe von w -1
LS=-1 && RS=-1 && GS=-1 => setzt Schlag von w auf -1

wiederhole Arbeitschritt 2 & 3 bis sich bei Farbe und Schlag nichts mehr ändert.

Arbeitsschritt 4:
gib eine Bewertung aus!

Bemerkung:
Die Arbeit wird nun in Arbeitsschritt 2 stattfinden, da hier die Möglichkeiten, zum Teil auch rekursiv
untersucht werden müssen.

Nun wieder zum Codieren:
Result.java soll die ausgewerteten Ergebnisse verwalten und nicht mehr. testende Strategieobjekte
sollen darauf zurückgreifen können:

Die Methoden:
public int isGuaterStich(Stich stich)
public int isRechterStich(Stich stich)	
public int isLinkerStich(Stich stich)
public int isSchlagStich(Stich stich)
public int isFarbstich(Stich stich) 

werden aus Result.java entfernt. Die Methoden um das Schlagarray anzupassen werden verfeinert:

public class Result {
	
	private boolean mitGuatem;
	private int[] schlag;
	private int[] trumpf;
	
	public Result(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		schlag = new int[CONSTANTS.ANZAHL_SCHLAEGE];  // alle automatisch auf 0 = POSSIBLE!
		trumpf = new int[CONSTANTS.ANZAHL_FARBEN];  // alle automatisch auf 0 = POSSIBLE!
	}
	
	// für die Testklassen
	public int[] getSchlagArray() { return schlag; }
	public int[] getFarbeArray() { return trumpf; }
	
	public int getSchlag() {
		return findFirstSURE(schlag);
	}
	
	public int getTrumpf() {
		return findFirstSURE(trumpf);
	}
	
	private int findFirstSURE(int[] testArray) {
		int position = testArray.length - 1;
		while(position >= 0 && testArray[position] != CONSTANTS.SURE) 
			position--;
		return position;
	}
	
	public boolean isSchlagFix() {
		return getSchlag() != CONSTANTS.IMPOSSIBLE;
	}
	
	public boolean isTrumpfFix() {
		return getTrumpf() != CONSTANTS.IMPOSSIBLE;
	}
	
	public boolean isRechterFix() {
		return (isSchlagFix() && isTrumpfFix());
	}
	
	public boolean isGuaterFix() {
		return isRechterFix();
	}
	
	public Card getRechter() {
		return new Card(getTrumpf(), getSchlag());
	}
	
	public Card getGuater() {
		return getRechter().getNextNumberCard();
	}
	
// nicht mehr mögliche Schläge auf IMPOSSIBLE setzen:
	public void calcSchlag(Stich[] stiche) {
		setLooserToImpossible(stiche);
		correctPreviousGuater(stiche);
		correctIfOnePossibleLeft();
	}

	private void setLooserToImpossible(Stich[] stiche) {
		Stich stich = stiche[getSticheSize(stiche) - 1];
		System.out.println(getSticheSize(stiche));
		for(Card card : stich.cards) 
			if(!((card.number == stich.cards[stich.winner].number) ||
			  (mitGuatem && card.number == stich.getWinner().number - 1)))
				this.schlag[card.number] = CONSTANTS.IMPOSSIBLE;
	}
	
	private void correctPreviousGuater(Stich[] stiche) {
		for(int stichNumber = 0; stichNumber < getSticheSize(stiche); stichNumber++) {
			if(schlag[stiche[stichNumber].getWinner().number] == CONSTANTS.IMPOSSIBLE &&
			stiche[stichNumber].findCard(stiche[stichNumber].getWinner().getPreviousNumberCard())) 
				schlag[stiche[stichNumber].getWinner().number - 1] = CONSTANTS.IMPOSSIBLE; 
		}
	}

	private int getSticheSize(Stich[] stiche) {
		int stich = 0;
		while(stiche[stich] != null && stich < stiche.length) stich++;
		return stich;
	}
	
	private void correctIfOnePossibleLeft() {
		int coutZeros = 0;
		int rememberZeroPosition = 0;
		for(int position = 0; position < schlag.length; position++)
			if(schlag[position] == CONSTANTS.POSSIBLE) {
				coutZeros++;
				rememberZeroPosition = position;
			}
		if(coutZeros == 1) schlag[rememberZeroPosition] = CONSTANTS.SURE;
	}
}

und die Tests dazu:

public class Test_Result extends TestCase {
	
	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	Stich[] stiche;
	
	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);
		
		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);
		
		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
		
		stiche = new Stich[5];
	}
	
	public void test_isSchlagFix_getSchlag() {
		Result result = new Result(false);
		int[] schlag = result.getSchlagArray();
		assertEquals(false,result.isSchlagFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getSchlag());
		
		schlag[CONSTANTS.SECHSER] = schlag[CONSTANTS.SIEBNER] = CONSTANTS.IMPOSSIBLE;
		assertEquals(false,result.isSchlagFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getSchlag());
		
		schlag[CONSTANTS.SECHSER] = CONSTANTS.SURE;
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.SECHSER,result.getSchlag());
		
		schlag[CONSTANTS.SECHSER] = CONSTANTS.IMPOSSIBLE;
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.AS,result.getSchlag());
	}
	
	public void test_isTrumpfFix_getTrumpf() {
		Result result = new Result(false);
		int[] farbe = result.getFarbeArray();
		assertEquals(false,result.isTrumpfFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getTrumpf());
		
		farbe[CONSTANTS.EICHEL] = farbe[CONSTANTS.HERZ] = CONSTANTS.IMPOSSIBLE;
		assertEquals(false,result.isTrumpfFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getTrumpf());
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.SURE;
		assertEquals(true,result.isTrumpfFix());
		assertEquals(CONSTANTS.EICHEL,result.getTrumpf());
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.IMPOSSIBLE;
		farbe[CONSTANTS.SCHELL] = CONSTANTS.SURE;
		assertEquals(true,result.isTrumpfFix());
		assertEquals(CONSTANTS.SCHELL,result.getTrumpf());
	}
	
	public void test_isRechterFix() {
		Result result = new Result(false);
		int[] schlag = result.getSchlagArray();
		int[] farbe = result.getFarbeArray();
		assertEquals(false,result.isRechterFix());
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.SURE;
		assertEquals(false,result.isRechterFix());
		
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		assertEquals(true,result.isRechterFix());
	}
	
	public void test_getRechter() {
		Result result = new Result(false);
		int[] schlag = result.getSchlagArray();
		int[] farbe = result.getFarbeArray();
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.SURE;
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		Card rechter = new Card(CONSTANTS.EICHEL,CONSTANTS.AS);
		assertEquals(true,result.getRechter().equals(rechter));
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.IMPOSSIBLE;
		schlag[CONSTANTS.AS] = CONSTANTS.IMPOSSIBLE;
		farbe[CONSTANTS.SCHELL] = CONSTANTS.SURE;
		schlag[CONSTANTS.SECHSER] = CONSTANTS.SURE;
		rechter = new Card(CONSTANTS.SCHELL,CONSTANTS.SECHSER);
		assertEquals(true,result.getRechter().equals(rechter));
	}
	
	public void test_getGuater() {
		Result result = new Result(false);
		int[] schlag = result.getSchlagArray();
		int[] farbe = result.getFarbeArray();
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.SURE;
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		Card guater = new Card(CONSTANTS.EICHEL,CONSTANTS.SIEBNER);
		assertEquals(true,result.getGuater().equals(guater));
		
		farbe[CONSTANTS.EICHEL] = CONSTANTS.IMPOSSIBLE;
		schlag[CONSTANTS.AS] = CONSTANTS.IMPOSSIBLE;
		farbe[CONSTANTS.SCHELL] = CONSTANTS.SURE;
		schlag[CONSTANTS.AS] = CONSTANTS.SURE;
		guater = new Card(CONSTANTS.SCHELL,CONSTANTS.SECHSER);
		assertEquals(true,result.getGuater().equals(guater));
	}
	
	public void test_calcSchlag_without_Guater() {
		
		Result result = new Result(false);
		stiche[0] = new Stich(hK,sK,sA,hA,0);
		result.calcSchlag(stiche);
		int[] kingBeatsAs = {0,0,0,0,0,0,0,0,-1};
		for(int i = 0; i < kingBeatsAs.length; i++)
			assertEquals(kingBeatsAs[i],result.getSchlagArray()[i]);
		
		result = new Result(false);
		stiche[0] = new Stich(hK,sK,sA,hA,1);
		result.calcSchlag(stiche);
		for(int i = 0; i < kingBeatsAs.length; i++)
			assertEquals(kingBeatsAs[i],result.getSchlagArray()[i]);
		
		result = new Result(false);
		stiche[0] = new Stich(hK,sK,sA,hA,2);
		result.calcSchlag(stiche);
		int[] asBeatsKing = {0,0,0,0,0,0,0,-1,0};
		for(int i = 0; i < asBeatsKing.length; i++)
			assertEquals(asBeatsKing[i],result.getSchlagArray()[i]);
		
		result = new Result(false);
		stiche[0] = new Stich(hK,sK,sA,hA,3);
		result.calcSchlag(stiche);
		for(int i = 0; i < asBeatsKing.length; i++)
			assertEquals(asBeatsKing[i],result.getSchlagArray()[i]);
		
		result = new Result(false);
		stiche[0] = new Stich(h10,sK,hK,hA,2);
		result.calcSchlag(stiche);
		int[] kingBeats10AndAs = {0,0,0,0,-1,0,0,0,-1};
		assertEquals(kingBeats10AndAs[4],result.getSchlagArray()[4]);
		for(int i = 0; i < kingBeats10AndAs.length; i++)
			assertEquals(kingBeats10AndAs[i],result.getSchlagArray()[i]);
		
		result = new Result(false);
		stiche[0] = new Stich(h10,s7,hK,hA,2);
		result.calcSchlag(stiche);
		int[] kingBeats7And10AndAs = {0,-1,0,0,-1,0,0,0,-1};
		assertEquals(kingBeats10AndAs[4],result.getSchlagArray()[4]);
		for(int i = 0; i < kingBeats7And10AndAs.length; i++)
			assertEquals(kingBeats7And10AndAs[i],result.getSchlagArray()[i]);
	}
	
	public void test_calcSchlag_with_Guater() {
		Result result = new Result(true);
		stiche[0] = new Stich(hK,sK,sA,hA,3);
		result.calcSchlag(stiche);
		int[] guaterAS = {0,0,0,0,0,0,0,0,0};
		for(int i = 0; i < guaterAS.length; i++)
			assertEquals(guaterAS[i],result.getSchlagArray()[i]);
		
		result = new Result(true);
		stiche[0] = new Stich(h7,h8,h9,h10,3);
		result.calcSchlag(stiche);
		int[] guater10 = {0,-1,-1,0,0,0,0,0,0};
		for(int i = 0; i < guater10.length; i++)
			assertEquals(guater10[i],result.getSchlagArray()[i]);
		
		result = new Result(true);
		stiche[0] = new Stich(h7,h8,h9,h10,2);
		result.calcSchlag(stiche);
		int[] guater9 = {0,-1,0,0,-1,0,0,0,0};
		for(int i = 0; i < guater9.length; i++)
			assertEquals(guater9[i],result.getSchlagArray()[i]);
	}
	
	public void test_correctPreviousGuater() {
		Result result = new Result(true);
		stiche[0] = new Stich(eK,s7,hU,hO,3);
		result.calcSchlag(stiche);
		int[] t1_after1 = {0,-1,0,0,0,0,0,-1,0};
		for(int i = 0; i < t1_after1.length; i++)
			assertEquals(t1_after1[i],result.getSchlagArray()[i]);
		
		stiche[1] = new Stich(h10,lO,s9,sA,0);
		result.calcSchlag(stiche);
		int[] t1_after2 = {0,-1,0,0,0,-1,-1,-1,-1};
		for(int i = 0; i < t1_after1.length; i++) 
			assertEquals(t1_after2[i],result.getSchlagArray()[i]);
	}
	
	public void test_calcSchlag_setSchlagToSureIfJustOnePossibleLeft() {
		Result result = new Result(true);
		int[] schlag = result.getSchlagArray();
		
		schlag[8]=0;
		schlag[0]=schlag[1]=schlag[2]=schlag[3]=schlag[4]=schlag[5]=schlag[6]=schlag[7]=-1;
		stiche[0] = new Stich(hK,sK,sA,hA,3);
		result.calcSchlag(stiche);
		int[] JustASLeft = {-1,-1,-1,-1,-1,-1,-1,-1,1};
		for(int i = 0; i < JustASLeft.length; i++)
			assertEquals(JustASLeft[i],result.getSchlagArray()[i]);
		
		schlag[0]=0;
		schlag[1]=schlag[2]=schlag[3]=schlag[4]=schlag[5]=schlag[6]=schlag[7]=schlag[8]=-1;
		stiche[0] = new Stich(hK,sK,sA,hA,3);
		result.calcSchlag(stiche);
		int[] Just6Left = {1,-1,-1,-1,-1,-1,-1,-1,-1};
		for(int i = 0; i < Just6Left.length; i++)
			assertEquals(Just6Left[i],result.getSchlagArray()[i]);
		
		schlag[5]=0;
		schlag[0]=schlag[1]=schlag[2]=schlag[3]=schlag[4]=schlag[6]=schlag[7]=schlag[8]=-1;
		stiche[0] = new Stich(hK,sK,sA,hA,3);
		result.calcSchlag(stiche);
		int[] JustULeft = {-1,-1,-1,-1,-1,1,-1,-1,-1};
		for(int i = 0; i < JustULeft.length; i++)
			assertEquals(JustULeft[i],result.getSchlagArray()[i]);
	}
	
}

Mühsam war das ändern von Stich auf ein Array von Stichen. Hier zeigt sich leider. dass das Ändern
der Test mühsamer als das Ändern des Programms ist!
Hier meint ein weiser Martin Fowler: "Veröffentliche keine unausgegöhrenen Schnittstellen!" Ha Ha!

Leider bleibt es nicht bei diesen Änderungen, aber aus Erfahrung wird man gekanntlich klug.
Stich[] stiche ist nicht besonders günstig, denn die wirkliche Größe muss erst mittels der Methode
getSticheSize(Stich[] stiche) abgefragt werden. Was übrigen beim Testen wieder verwirrt hatte. Das letzte
Element wurde benötigt, als hies die Methode zwischendurch getLast(), was dann beim Iterieren doch wieder 
zu einigen Problemen führte. Aber jetzt funktionieren zumindest die Tests.
Da die Stiche aber dynamisch einer nach dem anderen hinzugefügt werden, wäre es wohl doch besser das Array
durch eine Liste aus dem Java Collection Framework zu ersetzten. Die Wahl fällt auf: java.util.ArrayList<E>
Weiters wurde in Result so richtig aufgeräumt. Die beiden Arrays zu Aufnahme der Ergebnisse für Schlag 
und Trumpf werden als eigene Klasse ausgelagert.
Für was wäre wenn Untersuchungen sollte Result Cloneable sein!


Viele Namensänderungen, Umschichtungen, FEhlerkorrekturen später:

public class Card {
	public int color;
	public int number;
	
	public Card(int color, int number) {
		this.color = color;
		this.number = number;
	}
	
	public boolean equals(Card card) {
		return (card.color == this.color && card.number == this.number);
	}
	
	public Card getNextNumberCard() {
		int newNumber = this.number;
		newNumber = (newNumber + 1) % (CONSTANTS.AS + 1);
		if(color < CONSTANTS.SCHELL && newNumber == CONSTANTS.SECHSER) newNumber++;
		return new Card(color, newNumber);
	}
	
	public Card getPreviousNumberCard() {
		int newNumber = this.number;
		newNumber = (newNumber - 1 + CONSTANTS.AS + 1) % (CONSTANTS.AS + 1);
		if(color < CONSTANTS.SCHELL && newNumber == CONSTANTS.SECHSER) newNumber = CONSTANTS.AS;
		return new Card(color, newNumber);
	}
	
	public Card nextColorCard() {
		int newColor = this.color;
		newColor = (newColor + 1) % (CONSTANTS.SCHELL + 1);
		return new Card(newColor, number);
	}
}

import junit.framework.TestCase;

import watten.CONSTANTS;
import watten.Card;

public class Test_Card extends TestCase {

	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;

	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);

		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);

		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
	}

	public void test_getNextNumberCard() {
		assertEquals(true, eA.getNextNumberCard().equals(e7));
		assertEquals(true, hA.getNextNumberCard().equals(h7));
		assertEquals(true, lA.getNextNumberCard().equals(l7));
		assertEquals(true, sA.getNextNumberCard().equals(s6));
		assertEquals(true, s6.getNextNumberCard().equals(s7));
	}
	
	public void test_getpreviousNumberCard() {
		assertEquals(true, e7.getPreviousNumberCard().equals(eA));
		assertEquals(true, h7.getPreviousNumberCard().equals(hA));
		assertEquals(true, l7.getPreviousNumberCard().equals(lA));
		assertEquals(true, h9.getPreviousNumberCard().equals(h8));
	}
	
	public void test_nextColorCard() {
		assertEquals(true, s7.nextColorCard().equals(e7));
		assertEquals(true, e7.nextColorCard().equals(h7));
		assertEquals(true, h7.nextColorCard().equals(l7));
		assertEquals(true, l7.nextColorCard().equals(s7));
	}
}

public class Stich {
	public Card[] cards;
	public int winner;
	
	public Stich(Card card1, Card card2, Card card3, Card card4, int winner) {
		cards = new Card[4];
		cards[0] = card1;
		cards[1] = card2;
		cards[2] = card3;
		cards[3] = card4;
		this.winner = winner;
	}
	
	public Card getWinner() {
		return cards[winner];
	}
	
	public boolean findCard(Card card) {
		int position = 0;
		boolean cardFound = false;
		while(position < cards.length && !cardFound) {
			cardFound = cards[position].equals(card);
			position++;
		}
		return cardFound;
	}

	public boolean findNumber(int number) {
		int position = 0;
		boolean numberFound = false;
		while(position < cards.length && !numberFound) {
			numberFound = cards[position].number == number;
			position++;
		}
		return numberFound;
	}
	
	public boolean findColor(int color) {
		int position = 0;
		boolean colorFound = false;
		while(position < cards.length && !colorFound) {
			colorFound = cards[position].color == color;
			position++;
		}
		return colorFound;
	}
}

import junit.framework.TestCase;

public class Test_Stich extends TestCase {
	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	
	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);
		
		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);
		
		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
	}
	
	public void test_findCard() {
		Stich stich = new Stich(e7,e8,e9,e10,1);
		assertEquals(true, stich.findCard(e7));
		assertEquals(false, stich.findCard(h7));
		assertEquals(true, stich.findCard(e10));
	}
	
	public void test_findNumber() {
		Stich stich = new Stich(e7,e8,e9,e10,1);
		assertEquals(true, stich.findNumber(CONSTANTS.SIEBNER));
		assertEquals(true, stich.findNumber(CONSTANTS.ACHTER));
		assertEquals(true, stich.findNumber(CONSTANTS.NEUNER));
		assertEquals(true, stich.findNumber(CONSTANTS.ZEHNER));
		
		stich = new Stich(h7,e7,s8,l8,1);
		assertEquals(true, stich.findColor(CONSTANTS.SIEBNER));
		assertEquals(true, stich.findColor(CONSTANTS.LAUB));
	}
	
	public void test_findColor() {
		Stich stich = new Stich(e7,e8,e9,e10,1);
		assertEquals(true, stich.findColor(CONSTANTS.EICHEL));
		assertEquals(false, stich.findColor(CONSTANTS.LAUB));
		assertEquals(false, stich.findColor(CONSTANTS.HERZ));
		
		stich = new Stich(h7,e8,s9,l10,1);
		assertEquals(true, stich.findColor(CONSTANTS.EICHEL));
		assertEquals(true, stich.findColor(CONSTANTS.LAUB));
		assertEquals(true, stich.findColor(CONSTANTS.HERZ));
		assertEquals(true, stich.findColor(CONSTANTS.SCHELL));
	}
}

import java.util.ArrayList;

public class Result implements Cloneable {
	
	private boolean mitGuatem;
	private PossibilityArray schlag;
	private PossibilityArray trumpf;
	
	public Result(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		schlag = new PossibilityArray(CONSTANTS.ANZAHL_SCHLAEGE);  // alle automatisch auf 0 = POSSIBLE!
		trumpf = new PossibilityArray(CONSTANTS.ANZAHL_FARBEN);  // alle automatisch auf 0 = POSSIBLE!
	}
	
	public Result clone() throws CloneNotSupportedException {
		Result tempResult = new Result(mitGuatem);
		setArray(schlag, schlag.clone());
		setArray(trumpf, trumpf.clone());
		return tempResult;
	}
	
	private void setArray(PossibilityArray oldArray, PossibilityArray newArray) {
		newArray = oldArray;
	}
	
	public void setNumberAt(int position, int value) { schlag.setValueAt(position,value); }
	
	public void setColorAt(int position, int value) { trumpf.setValueAt(position,value); }
	
	public int getNumberAt(int position) { return schlag.get(position); }
	
	public int getColorAt(int position) { return trumpf.get(position); }
	
	public int getSchlag() { return schlag.findFirstSure(); }
	
	public int getTrumpf() { return trumpf.findFirstSure(); }
	
	public boolean isSchlagFix() { return getSchlag() != CONSTANTS.IMPOSSIBLE; }
	
	public boolean isTrumpfFix() { return getTrumpf() != CONSTANTS.IMPOSSIBLE; }
	
	public boolean isRechterFix() { return (isSchlagFix() && isTrumpfFix()); }
	
	public boolean isGuaterFix() { return isRechterFix(); }
	
	public Card getRechter() { return new Card(getTrumpf(), getSchlag()); }
	
	public Card getGuater() { return getRechter().getNextNumberCard(); }
	
	// nicht mehr mögliche Schläge auf IMPOSSIBLE setzen:
	public void calcSchlag(ArrayList<Stich> stiche) {
		setLooserToImpossible(stiche);
		if(mitGuatem) correctPreviousGuater(stiche);
	}

	private void setLooserToImpossible(ArrayList<Stich> stiche) {
		Stich lastStich = stiche.get(stiche.size() - 1);
		for(Card card : lastStich.cards) 
			if(!((          card.number == lastStich.getWinner().number) ||
			  (mitGuatem && card.number == lastStich.getWinner().number - 1)))
				this.schlag.setValueAt(card.number,CONSTANTS.IMPOSSIBLE);
	}
	
	private void correctPreviousGuater(ArrayList<Stich> stiche) {
		for(int stichNumber = 0; stichNumber < stiche.size(); stichNumber++) {
			if(isUncorretDoubleWinnerInStich(stiche, stichNumber)) 
				schlag.setValueAt(stiche.get(stichNumber).getWinner().number - 1,CONSTANTS.IMPOSSIBLE);
		}
	}
	
	private boolean isUncorretDoubleWinnerInStich(ArrayList<Stich> stiche, int stichNumber) {
		return 	schlag.get(stiche.get(stichNumber).getWinner().number) == CONSTANTS.IMPOSSIBLE &&
	    stiche.get(stichNumber).findNumber(stiche.get(stichNumber).getWinner().number - 1); 
	}
}

import java.util.ArrayList;

import junit.framework.TestCase;

public class Test_Result extends TestCase {
	
	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	ArrayList<Stich> stiche;
	
	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);
		
		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);
		
		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
		
		stiche = new ArrayList<Stich>(5);
	}
	
	public void test_clone() {
		try {
			Result result = new Result(false);
			result.setNumberAt(CONSTANTS.KOENIG,CONSTANTS.SURE);
			assertEquals(true,result.isSchlagFix());
			assertEquals(CONSTANTS.KOENIG,result.getSchlag());
			Result resultClone = result.clone();
			resultClone.setNumberAt(CONSTANTS.OBER,CONSTANTS.SURE);
			// Test, ob result unverändert!
			assertEquals(true,result.isSchlagFix());
			assertEquals(CONSTANTS.KOENIG,result.getSchlag());
			// Test, ob resultClone verändert
			assertEquals(true,resultClone.isSchlagFix());
			assertEquals(CONSTANTS.OBER,resultClone.getSchlag());
			
		} catch(CloneNotSupportedException e) { 
			System.out.println("PossibilityArray konnte nichtb geklont werden!");
		}
	}
	
	public void test_isSchlagFix_getSchlag() {
		Result result = new Result(false);
		result.setNumberAt(CONSTANTS.KOENIG,CONSTANTS.SURE);
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.KOENIG,result.getSchlag());
		
		result = new Result(false);
		result.setNumberAt(CONSTANTS.SECHSER,CONSTANTS.IMPOSSIBLE);
		result.setNumberAt(CONSTANTS.SIEBNER,CONSTANTS.IMPOSSIBLE);
		assertEquals(false,result.isSchlagFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getSchlag());
		
		result.setNumberAt(CONSTANTS.SECHSER,CONSTANTS.SURE);
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.SECHSER,result.getSchlag());
		
		result.setNumberAt(CONSTANTS.SECHSER,CONSTANTS.IMPOSSIBLE);
		result.setNumberAt(CONSTANTS.AS,CONSTANTS.SURE);
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.AS,result.getSchlag());
	}
	
	public void test_isTrumpfFix_getTrumpf() {
		Result result = new Result(false);
	
		assertEquals(false,result.isTrumpfFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getTrumpf());
		
		result.setColorAt(CONSTANTS.EICHEL,CONSTANTS.IMPOSSIBLE);
		result.setColorAt(CONSTANTS.HERZ,CONSTANTS.IMPOSSIBLE);
		assertEquals(false,result.isTrumpfFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getTrumpf());
		
		result.setColorAt(CONSTANTS.EICHEL,CONSTANTS.SURE);
		assertEquals(true,result.isTrumpfFix());
		assertEquals(CONSTANTS.EICHEL,result.getTrumpf());
		
		result.setColorAt(CONSTANTS.SCHELL,CONSTANTS.SURE);
		assertEquals(true,result.isTrumpfFix());
		assertEquals(CONSTANTS.SCHELL,result.getTrumpf());
	}
	
	public void test_isRechterFix() {
		Result result = new Result(false);
		
		assertEquals(false,result.isRechterFix());
		
		result.setColorAt(CONSTANTS.EICHEL,CONSTANTS.SURE);
		assertEquals(false,result.isRechterFix());
		
		result.setNumberAt(CONSTANTS.AS,CONSTANTS.SURE);
		assertEquals(true,result.isRechterFix());
	}
	
	public void test_getRechter() {
		Result result = new Result(false);
		
		result.setColorAt(CONSTANTS.EICHEL,CONSTANTS.SURE);
		result.setNumberAt(CONSTANTS.AS,CONSTANTS.SURE);
		Card rechter = new Card(CONSTANTS.EICHEL,CONSTANTS.AS);
		assertEquals(true,result.getRechter().equals(rechter));
		
		result.setColorAt(CONSTANTS.SCHELL,CONSTANTS.SURE);
		result.setNumberAt(CONSTANTS.SECHSER,CONSTANTS.SURE);
		rechter = new Card(CONSTANTS.SCHELL,CONSTANTS.SECHSER);
		assertEquals(true,result.getRechter().equals(rechter));
	}
	
	public void test_getGuater() {
		Result result = new Result(false);
		
		result.setColorAt(CONSTANTS.EICHEL,CONSTANTS.SURE);
		result.setNumberAt(CONSTANTS.AS,CONSTANTS.SURE);
		Card guater = new Card(CONSTANTS.EICHEL,CONSTANTS.SIEBNER);
		assertEquals(true,result.getGuater().equals(guater));
		
		result.setColorAt(CONSTANTS.SCHELL,CONSTANTS.SURE);
		result.setNumberAt(CONSTANTS.AS,CONSTANTS.SURE);
		guater = new Card(CONSTANTS.SCHELL,CONSTANTS.SECHSER);
		assertEquals(true,result.getGuater().equals(guater));
	}
	
	public void test_calcSchlag_without_Guater() {
		
		Result result = new Result(false);
		stiche.clear();
		// Rechter eK
		stiche.add(new Stich(hK,sU,sA,h9,0));	//6~,7~,8~,9-,10~,U-,O~,K~,A-
		result.calcSchlag(stiche);
		assertEquals(false,result.isSchlagFix());
		stiche.add(new Stich(lO,s6,e8,e10,3));	//6-,7~,8-,9-,10~,U-,O-,K~,A-
		result.calcSchlag(stiche);
		assertEquals(false,result.isSchlagFix());
		stiche.add(new Stich(l7,s10,eA,eK,3));	//6-,7-,8-,9-,10-,U-,O-,K~,A-
		result.calcSchlag(stiche);
		assertEquals(true,result.isSchlagFix());
		
		result = new Result(false);
		stiche.clear();
		// Rechter eK
		stiche.add(new Stich(hO,sU,sA,h9,0));	//6~,7~,8~,9-,10~,U-,O~,K~,A-
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(false,result.isSchlagFix());
	}
	
	public void test_calcSchlag_with_Guater() {
		Result result = new Result(true);
		stiche.clear();
		// Rechter eK
		stiche.add(new Stich(eO,sU,sA,h9,0));	//6~,7~,8~,9-,10~,U~,O~,K~,A-
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(false,result.isSchlagFix());
		
		stiche.add(new Stich(lO,s6,e8,e10,3));	//6-,7~,8-,9-,10~,U-,O-,K~,A-
		result.calcSchlag(stiche);
		// Unter sollte mit Ober, der ihn im vorigen Stich geschützt hat herausfallen!
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(false,result.isSchlagFix());
		
		stiche.add(new Stich(l7,s10,eA,eK,3));	//6-,7-,8-,9-,10-,U-,O-,K+,A-
		result.calcSchlag(stiche);
		assertEquals(true,result.isSchlagFix());
		
	}
}

Wow! Hoffentlich geschafft!

Und jetzt zu den Strategien:

Arbeitsschritt 2:
teste auf:
reinen Farbstich	FS 		T=-1 && S=-1
reiner Trumpfstich	TS		T=+1 && S=-1
reiner SchlagStich	SS		T=-1 && S=+1
reiner RechterStich	RS		T=+1 && S=+1
reiner GuaterStich	GS		T=+1 && S-1=+1

Codiert:
package watten;

public interface StichTestInterface {
	
	public int test();
}

import java.util.ArrayList;

public class FarbStichTest implements StichTestInterface {
	 
	Result result;
	ArrayList<Stich> stiche;
	boolean testNotPossible;
	
	public FarbStichTest(Result result, ArrayList<Stich> stiche) {
		this.result = result;
		this.stiche = stiche;
	}
	
	private boolean setTestCase() {
		Card lastWinner = stiche.get(stiche.size() - 1).getWinner();
		if((result.getNumberAt(lastWinner.number) == CONSTANTS.SURE) || 
		   (result.getColorAt(lastWinner.color) == CONSTANTS.SURE)) return false;
		else {
			result.setNumberAt(lastWinner.number,CONSTANTS.IMPOSSIBLE);
			result.setColorAt(lastWinner.color,CONSTANTS.IMPOSSIBLE);
			return true;
		}
	}
	
	public int test() {
		System.out.println(setTestCase());
		if(!setTestCase()) return CONSTANTS.IMPOSSIBLE;
		return CONSTANTS.POSSIBLE;
	}
}
 
Obiges Beispiel und die ergänzte Tabelle 

reinen Farbstich	FS 		T=-1 && S=-1		dann darf T=+1 || S=+1 nicht sein
reiner Trumpfstich	TS		T=+1 && S=-1		dann darf T=-1 || S=+1 nicht sein
reiner SchlagStich	SS		T=-1 && S=+1		dann darf T=+1 || S=-1 nicht sein
reiner RechterStich	RS		T=+1 && S=+1		dann darf T=-1 || S=-1 nicht sein
reiner GuaterStich	GS		T=+1 && S-1=+1		dann darf T=-1 || S-1=-1 nicht sein

zeigen, dass setTestCase() für alle Strategien gilt. Wir werden sie deshalb in eine Klasse
BasisStichTest() auslagern.

Somit ändert sich die Strategiestruktur wie folgt:

public interface StichTestInterface {
	
	public int test();
}

public class BasisStichTest implements StichTestInterface {
	
	Result result;
	ArrayList<Stich> stiche;
	
	public BasisStichTest(Result result, ArrayList<Stich> stiche) {
		this.result = result;
		this.stiche = stiche;
	}
	
	protected boolean setUpTestCase(Card card, int winnerNewNumberResult, int winnerNewColorResult) {
		if((result.getNumberAt(card.number) == -winnerNewNumberResult) || 
		   (result.getColorAt(card.color) == -winnerNewColorResult)) return false;
		else {
			result.setNumberAt(card.number,winnerNewNumberResult);
			result.setColorAt(card.color,winnerNewColorResult);
			return true;
		}
	}
	
	protected Card getLastWinner() { return stiche.get(stiche.size() - 1).getWinner(); }
	
	public int test() {
		return CONSTANTS.POSSIBLE;
	}
}

import java.util.ArrayList;

public class FarbStichTest extends BasisStichTest {
 
	public FarbStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	public int test() {
		if(!setUpTestCase(getLastWinner(),CONSTANTS.IMPOSSIBLE,CONSTANTS.IMPOSSIBLE)) 
			return CONSTANTS.IMPOSSIBLE;
		return CONSTANTS.POSSIBLE;
	}
}

und die Tests dazu:

import java.util.ArrayList;

import junit.framework.TestCase;

public class Test_FarbStichTest extends TestCase {

	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	ArrayList<Stich> stiche;
	FarbStichTest farbStichTest;
	
	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);
		
		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);
		
		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
		
		stiche = new ArrayList<Stich>(5);
	}

	public void test_test() {
		Result result = new Result(false);
		stiche.add(new Stich(hK,e7,s8,hA,3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		farbStichTest = new FarbStichTest(result,stiche);
		assertEquals(CONSTANTS.POSSIBLE,farbStichTest.test());
	}
}

Hoffentlich nur kurzer Exkurs zurück zu Result.java:
Ist clone() wirklich logisch?
Ist der Wraparound auch wirklich getestet?
und wirklich der neu eingefügte Testfall:
		stiche.add(new Stich(h7,sU,hA,h9,0));	//6~,7~,8~,9-,10~,U-,O~,K~,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));		
scheitert!

hier die neuen Versionen: 1 Tag Arbeit ;-(

import java.util.ArrayList;

public class Result implements Cloneable {
	
	private boolean mitGuatem;
	private PossibilityArray schlag;
	private PossibilityArray trumpf;
	
	public Result(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		schlag = new PossibilityArray(CONSTANTS.ANZAHL_SCHLAEGE);  // alle automatisch auf 0 = POSSIBLE!
		trumpf = new PossibilityArray(CONSTANTS.ANZAHL_FARBEN);  // alle automatisch auf 0 = POSSIBLE!
	}
	
	public Result clone() throws CloneNotSupportedException {
		Result tempResult = new Result(mitGuatem);
		setSchlagPossibilityArray(schlag.clone());
		setTrumpfPossibilityArray(trumpf.clone());
		return tempResult;
	}
	
	private void setSchlagPossibilityArray(PossibilityArray schlag) { this.schlag = schlag; }
	
	private void setTrumpfPossibilityArray(PossibilityArray trumpf) { this.trumpf = trumpf; }
	
	public void setNumberAt(int position, int value) { schlag.setValueAt(position,value); }
	
	public void setColorAt(int position, int value) { trumpf.setValueAt(position,value); }
	
	public int getNumberAt(int position) { return schlag.get(position); }
	
	public int getColorAt(int position) { return trumpf.get(position); }
	
	public int getSchlag() { return schlag.findFirstSure(); }
	
	public int getTrumpf() { return trumpf.findFirstSure(); }
	
	public boolean isSchlagFix() { return getSchlag() != CONSTANTS.IMPOSSIBLE; }
	
	public boolean isTrumpfFix() { return getTrumpf() != CONSTANTS.IMPOSSIBLE; }
	
	public boolean isRechterFix() { return (isSchlagFix() && isTrumpfFix()); }
	
	public boolean isGuaterFix() { return isRechterFix(); }
	
	public Card getRechter() { return new Card(getTrumpf(), getSchlag()); }
	
	public Card getGuater() { return getRechter().getNextNumberCard(); }
	
	// nicht mehr mögliche Schläge auf IMPOSSIBLE setzen:
	public void calcSchlag(ArrayList<Stich> stiche) {
		setLooserToImpossible(stiche);
		if(mitGuatem) correctPreviousLeftOut(stiche);
	}

	private void setLooserToImpossible(ArrayList<Stich> stiche) {
		Stich lastStich = stiche.get(stiche.size() - 1);
		for(Card card : lastStich.cards) 
			if(!hasWinnerOrPreviousToWinnerNumber(card, lastStich))
				this.schlag.setValueAt(card.number,CONSTANTS.IMPOSSIBLE);
	}
	
	private boolean hasWinnerOrPreviousToWinnerNumber(Card card, Stich lastStich) {
		// hat selbe Number wie der Winner
		if(card.number == lastStich.getWinner().number) return true;
		// alle Fälle, falls mit dem Guatengespielt wird
		if(mitGuatem) { 
			if(card.number == lastStich.getWinner().getPreviousNumberCard().number)
				return true;
		} 
		return false;
	}
	 
	private void correctPreviousLeftOut(ArrayList<Stich> stiche) {
		for(int stichNumber = 0; stichNumber < stiche.size(); stichNumber++) {
			// winner ist sicher kein Schlag, Rechter oder Guater
			if((schlag.get(stiche.get(stichNumber).getWinner().number) == CONSTANTS.IMPOSSIBLE) &&
			   (trumpf.get(stiche.get(stichNumber).getWinner().color) == CONSTANTS.IMPOSSIBLE))  
						for(Card card : stiche.get(stichNumber).cards) schlag.setValueAt(card.number,CONSTANTS.IMPOSSIBLE);
		}
	}
}

und die neuen Tests:

import java.util.ArrayList;

import watten.CONSTANTS;
import watten.Card;
import watten.Result;
import watten.Stich;

import junit.framework.TestCase;

public class Test_Result extends TestCase {
	
	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	ArrayList<Stich> stiche;
	
	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);
		
		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);
		
		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
		
		stiche = new ArrayList<Stich>(5);
	}
	
	public void test_clone() {
		try {
			Result result = new Result(false);
			result.setNumberAt(CONSTANTS.KOENIG,CONSTANTS.SURE);
			assertEquals(true,result.isSchlagFix());
			assertEquals(CONSTANTS.KOENIG,result.getSchlag());
			
			Result resultClone = result.clone();
			resultClone.setNumberAt(CONSTANTS.OBER,CONSTANTS.SURE);
			
			// Test, ob result unverändert!
			assertEquals(true,result.isSchlagFix());
			assertEquals(CONSTANTS.KOENIG,result.getSchlag());
			
			// Test, ob resultClone verändert
			assertEquals(true,resultClone.isSchlagFix());
			assertEquals(CONSTANTS.OBER,resultClone.getSchlag());
			
		} catch(CloneNotSupportedException e) { 
			System.out.println("PossibilityArray konnte nichtb geklont werden!");
		}
	}
	
	public void test_isSchlagFix_getSchlag() {
		Result result = new Result(false);
		result.setNumberAt(CONSTANTS.KOENIG,CONSTANTS.SURE);
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.KOENIG,result.getSchlag());
		
		result = new Result(false);
		result.setNumberAt(CONSTANTS.SECHSER,CONSTANTS.IMPOSSIBLE);
		result.setNumberAt(CONSTANTS.SIEBNER,CONSTANTS.IMPOSSIBLE);
		assertEquals(false,result.isSchlagFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getSchlag());
		
		result.setNumberAt(CONSTANTS.SECHSER,CONSTANTS.SURE);
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.SECHSER,result.getSchlag());
		
		result.setNumberAt(CONSTANTS.SECHSER,CONSTANTS.IMPOSSIBLE);
		result.setNumberAt(CONSTANTS.AS,CONSTANTS.SURE);
		assertEquals(true,result.isSchlagFix());
		assertEquals(CONSTANTS.AS,result.getSchlag());
	}
	
	public void test_isTrumpfFix_getTrumpf() {
		Result result = new Result(false);
	
		assertEquals(false,result.isTrumpfFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getTrumpf());
		
		result.setColorAt(CONSTANTS.EICHEL,CONSTANTS.IMPOSSIBLE);
		result.setColorAt(CONSTANTS.HERZ,CONSTANTS.IMPOSSIBLE);
		assertEquals(false,result.isTrumpfFix());
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getTrumpf());
		
		result.setColorAt(CONSTANTS.EICHEL,CONSTANTS.SURE);
		assertEquals(true,result.isTrumpfFix());
		assertEquals(CONSTANTS.EICHEL,result.getTrumpf());
		
		result.setColorAt(CONSTANTS.SCHELL,CONSTANTS.SURE);
		assertEquals(true,result.isTrumpfFix());
		assertEquals(CONSTANTS.SCHELL,result.getTrumpf());
	}
	
	public void test_isRechterFix() {
		Result result = new Result(false);
		
		assertEquals(false,result.isRechterFix());
		
		result.setColorAt(CONSTANTS.EICHEL,CONSTANTS.SURE);
		assertEquals(false,result.isRechterFix());
		
		result.setNumberAt(CONSTANTS.AS,CONSTANTS.SURE);
		assertEquals(true,result.isRechterFix());
	}
	
	public void test_getRechter() {
		Result result = new Result(false);
		
		result.setColorAt(CONSTANTS.EICHEL,CONSTANTS.SURE);
		result.setNumberAt(CONSTANTS.AS,CONSTANTS.SURE);
		Card rechter = new Card(CONSTANTS.EICHEL,CONSTANTS.AS);
		assertEquals(true,result.getRechter().equals(rechter));
		
		result.setColorAt(CONSTANTS.SCHELL,CONSTANTS.SURE);
		result.setNumberAt(CONSTANTS.SECHSER,CONSTANTS.SURE);
		rechter = new Card(CONSTANTS.SCHELL,CONSTANTS.SECHSER);
		assertEquals(true,result.getRechter().equals(rechter));
	}
	
	public void test_getGuater() {
		Result result = new Result(false);
		
		result.setColorAt(CONSTANTS.EICHEL,CONSTANTS.SURE);
		result.setNumberAt(CONSTANTS.AS,CONSTANTS.SURE);
		Card guater = new Card(CONSTANTS.EICHEL,CONSTANTS.SIEBNER);
		assertEquals(true,result.getGuater().equals(guater));
		
		result.setColorAt(CONSTANTS.SCHELL,CONSTANTS.SURE);
		result.setNumberAt(CONSTANTS.AS,CONSTANTS.SURE);
		guater = new Card(CONSTANTS.SCHELL,CONSTANTS.SECHSER);
		assertEquals(true,result.getGuater().equals(guater));
	}
	
	public void test_calcSchlag_without_Guater() {
		
		Result result = new Result(false);
		stiche.clear();
		// Rechter eK
		stiche.add(new Stich(hK,sU,sA,h9,0));	//6~,7~,8~,9-,10~,U-,O~,K~,A-
		result.calcSchlag(stiche);
		assertEquals(false,result.isSchlagFix());
		stiche.add(new Stich(lO,s6,e8,e10,3));	//6-,7~,8-,9-,10~,U-,O-,K~,A-
		result.calcSchlag(stiche);
		assertEquals(false,result.isSchlagFix());
		stiche.add(new Stich(l7,s10,eA,eK,3));	//6-,7-,8-,9-,10-,U-,O-,K~,A-
		result.calcSchlag(stiche);
		assertEquals(true,result.isSchlagFix());
		
		result = new Result(false);
		stiche.clear();
		// Rechter eK
		stiche.add(new Stich(hO,sU,sA,h9,0));	//6~,7~,8~,9-,10~,U-,O~,K~,A-
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(false,result.isSchlagFix());
	}
	
	public void test_calcSchlag_with_Guater_SingleTests() {
		Result result = new Result(true);
		stiche.clear();
		// Rechter eK
		stiche.add(new Stich(eO,sU,sA,h9,0));	//6~,7~,8~,9-,10~,U~,O~,K~,A-
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(false,result.isSchlagFix());
		//---------------------------------------
		result = new Result(true);
		stiche.clear();
		// Guater l7 Rechter lA
		stiche.add(new Stich(l7,s6,e8,e10,0));	//6-,7~,8-,9~,10-,U~,O~,K~,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		//---------------------------------------
		result = new Result(true);
		stiche.clear();
		// Guater l7 Rechter lA
		stiche.add(new Stich(l7,s6,e8,eA,0));	//6-,7~,8-,9~,10~,U~,O~,K~,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		//---------------------------------------
		result = new Result(true);
		result.setColorAt(CONSTANTS.SCHELL,CONSTANTS.POSSIBLE);
		stiche.clear();
		// Guater s7 Rechter s6
		stiche.add(new Stich(s7,s6,e8,eA,0));	//6~,7~,8-,9~,10~,U~,O~,K~,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.AS));
		//---------------------------------------
		result = new Result(true);
		result.setColorAt(CONSTANTS.SCHELL,CONSTANTS.POSSIBLE);
		stiche.clear();
		// Guater s7 Rechter s6
		stiche.add(new Stich(s7,h7,e8,eA,0));	//6~,7~,8-,9~,10~,U~,O~,K~,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.AS));
	}
	
	public void test_calcSchlag_with_Guater_SerienTests() {
		Result result = new Result(true);
		stiche.clear();
		// Rechter eK
		stiche.add(new Stich(eO,sU,sA,h9,0));	//6~,7~,8~,9-,10~,U~,O~,K~,A-
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(false,result.isSchlagFix());
		stiche.add(new Stich(lO,s6,e8,e10,3));	//6-,7~,8-,9-,10~,U~,O-,K~,A-
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(false,result.isSchlagFix());
		stiche.add(new Stich(l7,s10,eU,eK,3));	//6-,7-,8-,9-,10-,U~,O-,K+,A-
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.SURE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(true,result.isSchlagFix());
		//---------------------------------------
		// neues Spiel
		result = new Result(true);
		stiche.clear();
		// Guater l7 Rechter lA
		stiche.add(new Stich(l7,sU,hA,h9,0));	//6~,7~,8~,9-,10~,U-,O~,K~,A~
		result.calcSchlag(stiche);
		// As bleibt durch 7 geschützt
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(false,result.isSchlagFix());
		
		stiche.add(new Stich(h8,s6,eO,e9,1));	//6~,7~,8-,9-,10~,U-,O-,K~,A~
		result.calcSchlag(stiche);
		assertEquals(false,result.isSchlagFix());
		
		stiche.add(new Stich(s8,s10,sA,lK,2));	//6~,7~,8-,9-,10-,U-,O-,K~,A~
		result.calcSchlag(stiche);
		assertEquals(false,result.isSchlagFix());
		
		stiche.add(new Stich(lO,l10,eO,eK,0));	//6~,7~,8-,9-,10-,U-,O-,K-,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(false,result.isSchlagFix());
		
		stiche.add(new Stich(eA,h10,e7,eK,0));	//6~,7-,8-,9-,10-,U-,O-,K-,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(false,result.isSchlagFix());
		
		//---------------------------------------
		// neues Spiel
		result = new Result(true);
		stiche.clear();
		// Guater l7 Rechter lA
		stiche.add(new Stich(eU,sO,e7,eK,3));	//6~,7-,8~,9~,10~,U-,O~,K~,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		// Ober wird von König geschützt		
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(false,result.isSchlagFix());
		
		stiche.add(new Stich(lK,s6,eA,h8,2));	//6-,7-,8-,9~,10~,U-,O~,K~,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		// Ober wird von König beschützt, der wiederum von As beschützt wird!
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		// König wird von As beschütz
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(false,result.isSchlagFix());
		
		stiche.add(new Stich(s9,h10,hK,l7,3));	//6-,7-,8-,9-,10-,U-,O-,K-,A+
		result.setColorAt(CONSTANTS.LAUB,CONSTANTS.SURE);
		result.calcSchlag(stiche);
		
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.UNTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.SURE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(true,result.isSchlagFix());
		
		//---------------------------------------
		// neues Spiel
		result = new Result(true);
		stiche.clear();
		// Guater lK Rechter lO
		stiche.add(new Stich(eK,lO,e7,lK,3));	//6~,7-,8~,9~,10~,U~,O~,K~,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));	
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(false,result.isSchlagFix());
		
		stiche.add(new Stich(hK,lU,e8,s10,1));	//6~,7-,8-,9~,10~,U~,O~,K-,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));	
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(false,result.isSchlagFix());
		
		//---------------------------------------
		// neues Spiel
		result = new Result(true);
		stiche.clear();
		// Guater lK Rechter lO
		stiche.add(new Stich(e7,s10,e8,sK,2));	//6~,7~,8~,9~,10-,U~,O~,K-,A~
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));	
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(false,result.isSchlagFix());
		
		stiche.add(new Stich(l8,lU,h9,lO,3));	//6~,7~,8-,9-,10-,U~,O~,K-,A~
		//result.setColorAt(CONSTANTS.LAUB,CONSTANTS.SURE);
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));	
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(false,result.isSchlagFix());
		
		//selbe Auswerung wie oben, aber Laub als Schlag fix; 
		//7 muss nun wegen erstem 8 schlägt 7 herausfliegen
		result.setColorAt(CONSTANTS.LAUB,CONSTANTS.SURE);
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.SECHSER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.SIEBNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ACHTER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.NEUNER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.ZEHNER));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.UNTER));	
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.OBER));
		assertEquals(CONSTANTS.IMPOSSIBLE,result.getNumberAt(CONSTANTS.KOENIG));
		assertEquals(CONSTANTS.POSSIBLE,result.getNumberAt(CONSTANTS.AS));
		assertEquals(false,result.isSchlagFix());
		
	}
}
 
besonders das korrigieren von geschützten Schlägen erweißt sich als Problem:
Bsp:
Rechter: lO Guater lK
eK,lO,e7,lK,3	//6~,7-,8~,9~,10~,U~,O~,K~,A~
der König schützt den Ober
wird ein Stich später der König geschlagen, dann darf der Ober nicht auf - gesetzt werden.
andererseits:
Rechter: lO Guater lK
eO,h9,s7,eK,3	//6~,7-,8~,9~,10~,U~,O~,K~,A~
der König schützt den Ober
wird ein Stich später der König geschlagen, dann darf der Ober nicht auf - gesetzt werden, wenn:
klar ist, dass Eichel kein Trumpf ist!

Beim ausprogrammieren der Fälle wer, wen schlägt werden die Abfragen derart unübersichtlich, dass
evt. ein anderer Weg gesucht werden muss:
Ausserdem sind noch Fehler enthalten, die sie einzeln kaum herausfinden lassen.
z.B.: currentWinnerCard.equals müsste testCard.equals heissen!
if((result.getColorAt(testCard.color) == CONSTANTS.SURE) 
				&& 		// mit Guatem && testCard ist Guater
					((result.getMitGuatem() && result.isGuaterFix() && currentWinnerCard.equals(result.getGuater()))
					


import java.util.ArrayList;

public class BasisStichTest implements StichTestInterface {
	
	Result result;
	ArrayList<Stich> stiche;
	
	public BasisStichTest(Result result, ArrayList<Stich> stiche) {
		this.result = result;
		this.stiche = stiche;
	}
	
	protected boolean setUpTestCase(Card card, int winnerNewNumberResult, int winnerNewColorResult) {
		if((result.getNumberAt(card.number) == -winnerNewNumberResult) || 
		   (result.getColorAt(card.color) == -winnerNewColorResult)) return false;
		else {
			result.setNumberAt(card.number,winnerNewNumberResult);
			result.setColorAt(card.color,winnerNewColorResult);
			return true;
		}
	}
	
	protected Card getLastWinner() { return stiche.get(stiche.size() - 1).getWinner(); }
	
	public int test() { return CONSTANTS.POSSIBLE; }
	
	public int testWinner(int stichNumber) {
		Stich testStich = stiche.get(stichNumber);
		int currentWinnerPosition = 0;
		System.out.println("Start:" + currentWinnerPosition);
		Card currentWinnerCard = testStich.cards[currentWinnerPosition];
		//for(Card testCard : testStich.cards) {}
		for(int cardNumber = 1; cardNumber < testStich.cards.length; cardNumber++) {
			System.out.println("Trumpf:" + currentWinnerPosition + "cardNumber: " + cardNumber);
			Card testCard = testStich.cards[cardNumber];
			// testCard ist Trumpfkarte:
			if((result.getColorAt(testCard.color) == CONSTANTS.SURE) 
				&& 		// mit Guatem && testCard ist Guater
					((result.getMitGuatem() && result.isGuaterFix() && currentWinnerCard.equals(result.getGuater()))
					|| 	// mit Guatem && testCard ist Rechter und currentWinnerCard != Guater
					//(result.getMitGuatem() && result.isRechterFix() && !currentWinnerCard.equals(result.getGuater()))
					//||	// ohne Guatem && testCard ist Rechter
					(result.isRechterFix() && !currentWinnerCard.equals(result.getRechter()))
					||	// testCard ist Trumpf && currentWinnerCard kein Linker && höherer Trumpf
					((result.getNumberAt(currentWinnerCard.number) != CONSTANTS.SURE) && (testCard.color == currentWinnerCard.color) && (testCard.number > currentWinnerCard.number))
					||	// testCard ist Trumpf && currentWinnerCard kein Linker && currentWinnerCard kein Trumpf
					((result.getNumberAt(currentWinnerCard.number) != CONSTANTS.SURE) && (result.getColorAt(currentWinnerCard.color) == CONSTANTS.IMPOSSIBLE)))) {
				currentWinnerPosition = cardNumber;
				System.out.println("Trumpf:" + currentWinnerPosition + "cardNumber: " + cardNumber);
				currentWinnerCard = testStich.cards[currentWinnerPosition];
			}
			// testCard ist kein Trumpf
			else if(	!(  // Guater
						(result.getMitGuatem() && result.isGuaterFix() && currentWinnerCard.equals(result.getGuater()))
						|| // Rechter
						(result.isRechterFix() && currentWinnerCard.equals(result.getRechter()))
						|| // Linker
						(result.getNumberAt(currentWinnerCard.number) == CONSTANTS.SURE))
					&& 		//testCard ist Linker
						((result.getNumberAt(testCard.number) == CONSTANTS.SURE)
						||	// testCard hat höhere Nummer
						((testCard.color == currentWinnerCard.color) && (testCard.number > currentWinnerCard.number)))) {
				currentWinnerPosition = cardNumber;
				System.out.println("kein Trumpf:" + currentWinnerPosition);
				currentWinnerCard = testStich.cards[currentWinnerPosition];
			}
		}
		System.out.println(currentWinnerPosition);
		return currentWinnerPosition;
	}
}

hier die neue Klasse:

public class CardRelation {
	
	private Card card;
	private boolean trumpf;
	private boolean schlag;
	private boolean rechter;
	private boolean guater;
	
	public CardRelation(Card card, Result result) {
		this.card = card;
		if(card.number == CONSTANTS.SECHSER) trumpf = true;
		else trumpf = (result.getTrumpf() == card.color);
		schlag = (result.getSchlag() == card.number);
		rechter = schlag && trumpf;
		if(result.getMitGuatem() && result.isGuaterFix() && card.equals(result.getGuater())) guater = true;
	}

	
	public boolean beats(CardRelation testCard) {
		if(this.guater) return true;
		if(testCard.guater) return false;
		// ab hier kein "feindlicher" Guater mehr möglich!
		if(this.rechter) return true;
		if(testCard.rechter) return false;
		// ab hier kein "feindlicher" Rechter mehr möglich!
		if(this.schlag) return true;  // erster Schlag sieg über Schlag in der Klammer!
		if(testCard.schlag) return false;
		// ab hier kein "feindlicher" Linker mehr möglich!
		// Trumpf schlägt Trumpf;         
		if(this.trumpf && testCard.trumpf && (this.card.number > testCard.card.number)) return true;
		if(testCard.trumpf) return false;
		// ab hier kein "feindlicher" Trumpf mehr möglich
		// Trumpf schlägt Farbe
		if(this.trumpf) return true;
		// Farbe schlägt Farbe, erste Farbe siegt über zweite Farbe
		if(this.card.number >= testCard.card.number) return true;
		return false;
	}
}

und die Tests dazu:

import junit.framework.TestCase;

public class Test_CardRelation extends TestCase {
	
	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;

	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);

		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);

		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
	}


	public void test_beats() {
		Result result = new Result(true);
		result.setNumberAt(CONSTANTS.ZEHNER,CONSTANTS.SURE);
		result.setColorAt(CONSTANTS.LAUB,CONSTANTS.SURE);
		CardRelation guater = new CardRelation(lU,result);
		CardRelation rechter = new CardRelation(l10,result);
		CardRelation linker1 = new CardRelation(e10,result);
		CardRelation linker2 = new CardRelation(h10,result);
		CardRelation linker3 = new CardRelation(s10,result);
		CardRelation _s9 = new CardRelation(s9,result);
		CardRelation _sU = new CardRelation(sU,result);
		CardRelation _sK = new CardRelation(sK,result);
		CardRelation _sA = new CardRelation(sA,result);
		CardRelation _lO = new CardRelation(lO,result);
		CardRelation _lK = new CardRelation(lK,result);
		CardRelation _hU = new CardRelation(hU,result);
		CardRelation _hK = new CardRelation(hK,result);
		CardRelation veli = new CardRelation(s6,result);
		// Tests für Guater, Rechter(l10), Linker untereinander
		assertEquals(true,guater.beats(rechter)); 
		assertEquals(false,rechter.beats(guater));
		assertEquals(true,guater.beats(linker1)); 
		assertEquals(false,linker1.beats(guater));
		assertEquals(true,guater.beats(linker2)); 
		assertEquals(false,linker2.beats(guater));
		assertEquals(true,guater.beats(linker3)); 
		assertEquals(false,linker3.beats(guater));
		assertEquals(true,rechter.beats(linker1)); 
		assertEquals(false,linker1.beats(rechter));
		assertEquals(true,rechter.beats(linker2)); 
		assertEquals(false,linker2.beats(rechter));
		assertEquals(true,rechter.beats(linker3)); 
		assertEquals(false,linker3.beats(rechter));
		assertEquals(true,linker1.beats(linker2));
		assertEquals(true,linker1.beats(linker3));
		assertEquals(true,linker2.beats(linker1));
		assertEquals(true,linker2.beats(linker3));
		assertEquals(true,linker3.beats(linker1));
		assertEquals(true,linker3.beats(linker2));
		assertEquals(true,linker2.beats(veli));
		assertEquals(false,veli.beats(linker2));
		assertEquals(true,linker3.beats(veli));
		assertEquals(false,veli.beats(linker3));
		// Tests für Guater, Rechter(l10), Linker auf Trumpf
		assertEquals(true,guater.beats(_lO));
		assertEquals(false,_lO.beats(guater));
		assertEquals(true,rechter.beats(_lO)); 
		assertEquals(false,_lO.beats(rechter));
		assertEquals(true,linker3.beats(_lO)); 
		assertEquals(false,_lO.beats(linker3));
		// Tests für Guater, Rechter(l10), Linker auf Farbe
		assertEquals(true,guater.beats(_hK));
		assertEquals(false,_hK.beats(guater));
		assertEquals(true,rechter.beats(_hK)); 
		assertEquals(false,_hK.beats(rechter));
		assertEquals(true,linker3.beats(_hK)); 
		assertEquals(false,_hK.beats(linker3));
		// Tests Trumpf auf Trumpf
		assertEquals(true,_lK.beats(_lO));
		assertEquals(false,_lO.beats(_lK));
		assertEquals(true,rechter.beats(_hK)); 
		assertEquals(false,_hK.beats(rechter));
		assertEquals(true,linker3.beats(_hK)); 
		assertEquals(false,_hK.beats(linker3));
		assertEquals(true,_lK.beats(veli));
		assertEquals(false,veli.beats(_lK));
		// Trumpf auf Farbe
		assertEquals(true,veli.beats(_hK));
		assertEquals(false,_hK.beats(veli));
		assertEquals(true,_lK.beats(_hK)); 
		assertEquals(false,_hK.beats(_lK));
		assertEquals(true,_lO.beats(_hK)); 
		assertEquals(false,_hK.beats(_lO));
		// Farbe auf Farbe
		assertEquals(true,_sK.beats(_sU));
		assertEquals(false,_sU.beats(_sK));
		assertEquals(true,_sK.beats(_hK)); 
		assertEquals(true,_hK.beats(_sK));
	}
}

bis es allerdings soweit war, strotze es nur so von Fehlern:
z.B.:
zuerst ohne this.card = card
in if(..6) zuerst ohne else: => trumpf wurde zuerst auf true und dann wieder auf false gestellt.
trumpf, schlag und rechter wurden auch erst im 2. Anlauf gestaltet.

public CardRelation(Card card, Result result) {
		this.card = card;
		if(card.number == CONSTANTS.SECHSER) trumpf = true;
		else trumpf = (result.getTrumpf() == card.color);
		schlag = (result.getSchlag() == card.number);
		rechter = schlag && trumpf;
		if(result.getMitGuatem() && result.isGuaterFix() && card.equals(result.getGuater())) guater = true;
	}
	
In beats wurden beim kopieren zuerst einige true und false verwechselt.
Schlimmer jedoch:
Der Fall 
if(this.trumpf) return true; Trumpf schlägt Farbe wurde zuerst komplett vergessen.
und in 
if(this.card.number >= testCard.card.number) return true;
wurde das = nicht bedacht.
Dies alles wurde beim Testen entdeckt.

public boolean beats(CardRelation testCard) {
		if(this.guater) return true;
		if(testCard.guater) return false;
		// ab hier kein "feindlicher" Guater mehr möglich!
		if(this.rechter) return true;
		if(testCard.rechter) return false;
		// ab hier kein "feindlicher" Rechter mehr möglich!
		if(this.schlag) return true;  // erster Schlag sieg über Schlag in der Klammer!
		if(testCard.schlag) return false;
		// ab hier kein "feindlicher" Linker mehr möglich!
		// Trumpf schlägt Trumpf;         
		if(this.trumpf && testCard.trumpf && (this.card.number > testCard.card.number)) return true;
		if(testCard.trumpf) return false;
		// ab hier kein "feindlicher" Trumpf mehr möglich
		// Trumpf schlägt Farbe
		if(this.trumpf) return true;
		// Farbe schlägt Farbe, erste Farbe siegt über zweite Farbe
		if(this.card.number >= testCard.card.number) return true;
		return false;
	}
	
testWinner in BasisStichTest.java wird nun zu:

public int findWinner(int stichNumber) {
		//Stich testStich = stiche.get(stichNumber);
		int currentWinnerPosition = 0;
		//Card currentWinnerCard = testStich.cards[currentWinnerPosition];
		//for(int cardNumber = 1; cardNumber < testStich.cards.length; cardNumber++) {
		for(int cardNumber = 1; cardNumber < stiche.get(stichNumber).cards.length; cardNumber++) {
			//Card testCard = testStich.cards[cardNumber];
			//if(!(new CardRelation(currentWinnerCard,result).beats(new CardRelation(testCard,result)))) currentWinnerPosition = cardNumber;
			if(!(new CardRelation(stiche.get(stichNumber).cards[currentWinnerPosition],result).beats(new CardRelation(stiche.get(stichNumber).cards[cardNumber],result)))) currentWinnerPosition = cardNumber;
			
		}
		//System.out.println(currentWinnerPosition);
		return currentWinnerPosition;
	}
}

oder ganz schön kurz:

public int findWinner(int stichNumber) {
		int currentWinnerPosition = 0;
		for(int cardNumber = 1; cardNumber < stiche.get(stichNumber).cards.length; cardNumber++) 
			if(!(new CardRelation(stiche.get(stichNumber).cards[currentWinnerPosition],result).beats(new CardRelation(stiche.get(stichNumber).cards[cardNumber],result)))) 
				currentWinnerPosition = cardNumber;
		return currentWinnerPosition;
	}
	
Der Zugriff auf beats ist etwas lang, aber im Vergleich zur Version 1 mit den ganzen ||, deren Programmierung
doch auch mindestens 4 Stunden gekostet hat, wunderschön!


weiter gehts jetzt mit dem Farbstichtest:

import java.util.ArrayList;

public class FarbStichTest extends BasisStichTest {
 
	public FarbStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	protected boolean setUpTestCase(Card card, int winnerNewNumberResult, int winnerNewColorResult) {
		return super.setUpTestCase(card,CONSTANTS.IMPOSSIBLE,CONSTANTS.IMPOSSIBLE) &&
		setAllColorsToImpossible();
	}
	// In einem Farbstich kann kein Trumpf vorhanden sein!
	private boolean setAllColorsToImpossible() {
		for(int position = 0; position < stiche.get(stiche.size()-1).cards.length; position++) {
			if(result.getColorAt(stiche.get(stiche.size()-1).cards[position].color) == CONSTANTS.SURE) 
				return false; 
			else 
				result.setColorAt(stiche.get(stiche.size()-1).cards[position].color,CONSTANTS.IMPOSSIBLE);
		}
		return true;
	}
	
	public int test() {
		if(!setUpTestCase(stiche.get(stiche.size() - 1).getWinner(),CONSTANTS.IMPOSSIBLE,CONSTANTS.IMPOSSIBLE)) 
			return CONSTANTS.IMPOSSIBLE;
		return testPreviosWinner();
	}
	
	private int testPreviosWinner() {
		for(int stichNumber = 0; stichNumber < stiche.size(); stichNumber++) {
			if(findWinner(stichNumber) != stiche.get(stichNumber).winner) 
				if(correctWinner() == CONSTANTS.IMPOSSIBLE) return CONSTANTS.IMPOSSIBLE;
				else if(testPreviosWinner() == CONSTANTS.IMPOSSIBLE) return CONSTANTS.IMPOSSIBLE;
		}
		return CONSTANTS.POSSIBLE;
	}
	
	private int correctWinner() {
		return 0;
	}
}

Dann ändern wir gleich noch den Namen von
setAllColorsToImpossible()
setAllColorsInLastStichToImpossible()


Oh wei, oh wei schon wieder ein Problem mit einem alten Fehler:
In CardRealation schlägt eine Karte mit höherer Nummer eine vorherige Karte verschiedener Farbe.
Es fragt sich warum dieser Fall noch nicht aufgetaucht ist?
stiche.add(new Stich(e7,hA,l7,e8,3));
Daher zurüch zu den Test von CardRelation.

		if(this.card.number >= testCard.card.number) return true;
		return false;


verbessert auf:
	public boolean beats(CardRelation testCard) {
		if(this.guater) return true;
		if(testCard.guater) return false;
		// ab hier kein "feindlicher" Guater mehr möglich!
		if(this.rechter) return true;
		if(testCard.rechter) return false;
		// ab hier kein "feindlicher" Rechter mehr möglich!
		if(this.schlag) return true;  // erster Schlag sieg über Schlag in der Klammer!
		if(testCard.schlag) return false;
		// ab hier kein "feindlicher" Linker mehr möglich!
		// Trumpf schlägt Trumpf;         
		if(this.trumpf && testCard.trumpf && (this.card.number > testCard.card.number)) return true;
		if(testCard.trumpf) return false;
		// ab hier kein "feindlicher" Trumpf mehr möglich
		// Trumpf schlägt Farbe
		if(this.trumpf) return true;
		// Farbe schlägt Farbe, erste Farbe siegt über verschiedene zweite Farbe
		if(this.card.color != testCard.card.color) return true;
		// Farbe schlägt gleiche Farbe
		if(this.card.number >= testCard.card.number) return true;
		return false;
	}
	
	
und wieder zurück zu den Tests von FarbStichTest:

FarbStichTest und das wichtigere BasiStichTest sehen nun wie folgt aus:

import java.util.ArrayList;

public class BasisStichTest implements StichTestInterface {
	
	Result result;
	ArrayList<Stich> stiche;
	Card winnerCard;
	
	public BasisStichTest(Result result, ArrayList<Stich> stiche) {
		this.result = result;
		this.stiche = stiche;
	}
	
	protected boolean setUpTestCase(Card card, int winnerNewNumberResult, int winnerNewColorResult) {
		this.winnerCard = card;
		if((result.getNumberAt(card.number) == -winnerNewNumberResult) || 
		   (result.getColorAt(card.color) == -winnerNewColorResult)) return false;
		else {
			result.setNumberAt(card.number,winnerNewNumberResult);
			result.setColorAt(card.color,winnerNewColorResult);
			return true;
		}
	}
	
	//protected Card getLastWinner() { return stiche.get(stiche.size() - 1).getWinner(); }
	
	public int test() { return CONSTANTS.POSSIBLE; }
	
	public int findWinner(int stichNumber) {
		int currentWinnerPosition = 0;
		for(int cardNumber = 1; cardNumber < stiche.get(stichNumber).cards.length; cardNumber++) 
			if(!(new CardRelation(stiche.get(stichNumber).cards[currentWinnerPosition],result).beats(new CardRelation(stiche.get(stichNumber).cards[cardNumber],result)))) 
				currentWinnerPosition = cardNumber;
		return currentWinnerPosition;
	}

	protected int testPreviousWinner() {
		for(int stichNumber = 0; stichNumber < stiche.size(); stichNumber++) {
			if(findWinner(stichNumber) != stiche.get(stichNumber).winner) 
				if(!correctWinner(stichNumber)) 
					return CONSTANTS.IMPOSSIBLE;
		}
		return CONSTANTS.POSSIBLE;
	}
	
	private boolean correctWinner(int stichNumber) { 
		int testValueColorUp = CONSTANTS.POSSIBLE;
		int testValueNumberUp = CONSTANTS.POSSIBLE;
		try {
			if((winnerCard.color != stiche.get(stichNumber).getWinner().color) && 
			   (result.getColorAt(stiche.get(stichNumber).getWinner().color) != CONSTANTS.IMPOSSIBLE)) {
				Result saveResult = result.clone();
				result.setColorAt(stiche.get(stichNumber).getWinner().color,CONSTANTS.SURE);
				testValueColorUp = testPreviousWinner();
				result = saveResult;
				System.out.println("correct Color: " + result.getColorAt(stiche.get(stichNumber).getWinner().color));
			} 
			else testValueColorUp = CONSTANTS.IMPOSSIBLE;
			if((winnerCard.number != stiche.get(stichNumber).getWinner().number) &&
			   (result.getNumberAt(stiche.get(stichNumber).getWinner().number) != CONSTANTS.IMPOSSIBLE))	{
				Result saveResult = result.clone();
				result.setNumberAt(stiche.get(stichNumber).getWinner().number,CONSTANTS.SURE);
				testValueNumberUp = testPreviousWinner();
				result = saveResult;
				System.out.println("correct Number: " + result.getNumberAt(stiche.get(stichNumber).getWinner().number));
			}
			else testValueNumberUp = CONSTANTS.IMPOSSIBLE;
		} 
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!");
		}
		if(testValueColorUp == CONSTANTS.IMPOSSIBLE && testValueNumberUp == CONSTANTS.IMPOSSIBLE) {
			System.out.println("weder Trumpf noch Schlag könnten erhöht werden!");
			return false;
		}
		return true;
	}
}

import java.util.ArrayList;

public class FarbStichTest extends BasisStichTest {
 
	public FarbStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	protected boolean setUpTestCase(Card card, int winnerNewNumberResult, int winnerNewColorResult) {
		return super.setUpTestCase(card,CONSTANTS.IMPOSSIBLE,CONSTANTS.IMPOSSIBLE) &&
		setAllColorsInLastStichToImpossible(); // In einem Farbstich kann kein Trumpf vorhanden sein!
	}
	
	private boolean setAllColorsInLastStichToImpossible() {
		for(int position = 0; position < stiche.get(stiche.size()-1).cards.length; position++) {
			if(result.getColorAt(stiche.get(stiche.size()-1).cards[position].color) == CONSTANTS.SURE) 
				return false; 
			else 
				result.setColorAt(stiche.get(stiche.size()-1).cards[position].color,CONSTANTS.IMPOSSIBLE);
		}
		return true;
	}
	
	public int test() {
		if(!setUpTestCase(stiche.get(stiche.size() - 1).getWinner(),CONSTANTS.IMPOSSIBLE,CONSTANTS.IMPOSSIBLE)) 
			return CONSTANTS.IMPOSSIBLE;
		return testPreviousWinner();
	}
}


und die tests dazu in FarbStichTest

import java.util.ArrayList;

import junit.framework.TestCase;

public class Test_FarbStichTest extends TestCase {

	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	ArrayList<Stich> stiche;
	FarbStichTest farbStichTest;
	
	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);
		
		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);
		
		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
		
		stiche = new ArrayList<Stich>(5);
	}
	
	public void test_test_erster_Stich_Farbstich() {
		Result result = new Result(false);
		
		stiche.add(new Stich(e7,h7,l7,e9,3));
		assertEquals(CONSTANTS.POSSIBLE,new FarbStichTest(result,stiche).test());
		
		result = new Result(false);
		stiche.add(new Stich(eA,h7,l7,e9,0));
		assertEquals(CONSTANTS.POSSIBLE,new FarbStichTest(result,stiche).test());
	}

	
	public void test_test_one_Color_is_Trumpf() {
		Result result = new Result(false);
		farbStichTest = new FarbStichTest(result,stiche);
		
		stiche.add(new Stich(e7,h7,l7,l8,0));
		result.setColorAt(CONSTANTS.EICHEL,CONSTANTS.SURE);
		assertEquals(CONSTANTS.IMPOSSIBLE,farbStichTest.test());
		
		result.setColorAt(CONSTANTS.HERZ,CONSTANTS.SURE);
		assertEquals(CONSTANTS.IMPOSSIBLE,farbStichTest.test());
		
		result.setColorAt(CONSTANTS.LAUB,CONSTANTS.SURE);
		assertEquals(CONSTANTS.IMPOSSIBLE,farbStichTest.test());
		
		stiche.clear();
		stiche.add(new Stich(e7,h7,s7,s8,3));
		farbStichTest = new FarbStichTest(result,stiche);
		result.setColorAt(CONSTANTS.SCHELL,CONSTANTS.SURE);
		assertEquals(CONSTANTS.IMPOSSIBLE,farbStichTest.test());
	}


	public void test_test_4_Colors() {
		Result result = new Result(false);
		stiche.clear();
		stiche.add(new Stich(e7,h7,l7,s8,0));
		farbStichTest = new FarbStichTest(result,stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE,farbStichTest.test());
	}
	
	public void test_test_correct() {
		Result result = new Result(false);
		stiche.clear();
		stiche.add(new Stich(h7,hA,l7,e8,3));
		result.calcSchlag(stiche);
		farbStichTest = new FarbStichTest(result,stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE,farbStichTest.test());
	}

	public void test_test_serien_tests() {
		System.out.println("serien_tests");
		try {
			// Annahme: Rechter e9
			Result result = new Result(true);
			stiche.clear();
			stiche.add(new Stich(e7,hA,l7,e8,3));
			result.calcSchlag(stiche);
			farbStichTest = new FarbStichTest(result.clone(),stiche);
			assertEquals(CONSTANTS.POSSIBLE,farbStichTest.test());
			// hier folgt, dass im Falle eines Farbstiches e,s,l keine Trümpfe sein können
			// => h = Trumpf und Widerspruch hA sticht nicht e8
			// e8 müsste aber dann auf linken korrigiert werden!
			stiche.add(new Stich(e9,sK,lU,e10,3));
			result.calcSchlag(stiche);
			farbStichTest = new FarbStichTest(result.clone(),stiche);
			assertEquals(CONSTANTS.POSSIBLE,farbStichTest.test());
		} 
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!"); 
		}	
	}
}

Da der Fall Korrektur auf den Guaten noch fehlt, werden wir zuerst refraktionieren, dann weiter testen 
und dann den fall für den Guaten eingauen.

Da jeder Test das übergebene Result verändert scheint es sinnvoll Result bereits im Konstruktor zu klonen!

Doch leider stellt sich heraus, dass Result seine PossibilityArrays nicht richtig klont!
Die PossibilityArrays stimmen zwar noch, doch das tiefe klonen in Result scheint Probleme zu machen.
Daher wieder zurück zu Result!

zuerst werden die Tests um:
// hat der Clone die Daten mitbekommen?
			assertEquals(true,resultClone.isSchlagFix());
			assertEquals(CONSTANTS.KOENIG,resultClone.getSchlag());
erweitert, eigentlich vervollständigt!

public void test_clone() {
		try {
			Result result = new Result(false);
			
			result.setNumberAt(CONSTANTS.KOENIG,CONSTANTS.SURE);
			assertEquals(true,result.isSchlagFix());
			assertEquals(CONSTANTS.KOENIG,result.getSchlag());
			// klonen
			Result resultClone = result.clone();
			// hat der Clone die Daten mitbekommen?
			assertEquals(true,resultClone.isSchlagFix());
			assertEquals(CONSTANTS.KOENIG,resultClone.getSchlag());
			// resultClone wird nun verändert!
			resultClone.setNumberAt(CONSTANTS.OBER,CONSTANTS.SURE);
			// Test, ob result unverändert!
			assertEquals(true,result.isSchlagFix());
			assertEquals(CONSTANTS.KOENIG,result.getSchlag());
			
			// Test, ob resultClone verändert
			assertEquals(true,resultClone.isSchlagFix());
			assertEquals(CONSTANTS.OBER,resultClone.getSchlag());
			
		} catch(CloneNotSupportedException e) { 
			System.out.println("PossibilityArray konnte nicht geklont werden!");
		}
	}

dan diese dann scheitern, wird clone() gerichtet!

	public Result clone() throws CloneNotSupportedException {
		Result tempResult = new Result(mitGuatem);
		setSchlagPossibilityArray(schlag.clone());
		setTrumpfPossibilityArray(trumpf.clone());
		return tempResult;
	}
	
geändert auf tempResult.set.. damit die Daten auch im richtigen Objekt gesetz werden.
	
	public Result clone() throws CloneNotSupportedException {
		Result tempResult = new Result(mitGuatem);
		tempResult.setSchlagPossibilityArray(schlag.clone());
		tempResult.setTrumpfPossibilityArray(trumpf.clone());
		return tempResult;
	}

Nachdem das nun erledigt ist, wären weitere Tests für den Korrekturmechanismus nötig!
Hier sind sie. Noch etwas dürftig! Aber mehr wollte mir im Augenblick nicht einfallen.

		System.out.println("serien_tests Nr. 2");
		result = new Result(true);
		stiche.clear();
		stiche.add(new Stich(e7, hA, l7, e8, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).test());
		
		stiche.add(new Stich(e9, sK, lU, e10, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).test());
		


import java.util.ArrayList;

public class BasisStichTest implements StichTestInterface {
	
	Result result;
	ArrayList<Stich> stiche;
	Card keyCard;
	
	public BasisStichTest(Result result, ArrayList<Stich> stiche) {
		try {
			this.result = result.clone();
		} 
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!"); 
		}	
		this.stiche = stiche;
	}
	
	protected boolean setUpTestCase(Card card, int winnerNewNumberResult, int winnerNewColorResult) {
		this.keyCard = card;
		if((result.getNumberAt(card.number) == -winnerNewNumberResult) || 
		   (result.getColorAt(card.color) == -winnerNewColorResult)) return false;
		else {
			result.setNumberAt(card.number,winnerNewNumberResult);
			result.setColorAt(card.color,winnerNewColorResult);
			return true;
		}
	}
	
	public int test() { return CONSTANTS.POSSIBLE; }
	
	public int findWinner(int stichNumber) {
		int currentWinnerPosition = 0;
		for(int cardNumber = 1; cardNumber < stiche.get(stichNumber).cards.length; cardNumber++) 
			if(!(new CardRelation(stiche.get(stichNumber).cards[currentWinnerPosition],result).beats(new CardRelation(stiche.get(stichNumber).cards[cardNumber],result)))) 
				currentWinnerPosition = cardNumber;
		return currentWinnerPosition;
	}

	protected int testPreviousWinner() {
		for(int stichNumber = 0; stichNumber < stiche.size(); stichNumber++) {
			if(findWinner(stichNumber) != stiche.get(stichNumber).winner) 
				if(!correctWinner(stichNumber)) 
					return CONSTANTS.IMPOSSIBLE;
		}
		return CONSTANTS.POSSIBLE;
	}
	
	private boolean correctWinner(int stichNumber) { 
		if(correctColor(stichNumber) == CONSTANTS.IMPOSSIBLE &&
		   correctNumber(stichNumber) == CONSTANTS.IMPOSSIBLE)
		{
			System.out.println("weder Trumpf noch Schlag könnten erhöht werden!");
			return false;
		}
		return true;
	}
	
	private int correctColor(int stichNumber) {
		int testValueColorUp = CONSTANTS.POSSIBLE;
		try {
			if(!isColorBlocked(stichNumber)) {
				Result saveResult = result.clone();
				result.setColorAt(stiche.get(stichNumber).getWinner().color,CONSTANTS.SURE);
				testValueColorUp = testPreviousWinner();
				result = saveResult;
				System.out.println("corrected Color: " + stiche.get(stichNumber).getWinner().color);
			} 
			else testValueColorUp = CONSTANTS.IMPOSSIBLE;
		} 
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!");
		}
		return testValueColorUp;
	}
	
	private boolean isColorBlocked(int stichNumber) {
		return (keyCard.color == stiche.get(stichNumber).getWinner().color) || 
	   (result.getColorAt(stiche.get(stichNumber).getWinner().color) == CONSTANTS.IMPOSSIBLE);
	}
	
	private int correctNumber(int stichNumber) {
		int testValueNumberUp = CONSTANTS.POSSIBLE;
		try {
			if(!isNumberBlocked(stichNumber)) {
				Result saveResult = result.clone();
				result.setNumberAt(stiche.get(stichNumber).getWinner().number,CONSTANTS.SURE);
				testValueNumberUp = testPreviousWinner();
				result = saveResult;
				System.out.println("corrected Number: " + stiche.get(stichNumber).getWinner().number);
			}
			else testValueNumberUp = CONSTANTS.IMPOSSIBLE;
		} 
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!");
		}
		return testValueNumberUp;
	}
	
	private boolean isNumberBlocked(int stichNumber) {
		return (keyCard.number == stiche.get(stichNumber).getWinner().number) || 
	   (result.getNumberAt(stiche.get(stichNumber).getWinner().number) == CONSTANTS.IMPOSSIBLE);
	}
	
	private int correctToGuater(int stichNumber) {
		int testGuaterUp = CONSTANTS.POSSIBLE;
		
		return testGuaterUp;
	}
}


Durch den Testfall:

stiche.clear();
		
		stiche.add(new Stich(e7, sO, lA, sK, 1));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 0 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).test());
		
		stiche.add(new Stich(e9, sK, sU, e10, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 1 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).test());
		
		stiche.add(new Stich(e8, lK, lU, l8, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 2 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).test());
		
		stiche.add(new Stich(s6, hK, l7, s10, 3));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 3 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).test());

Fehler in 

private boolean isColorBlocked(int stichNumber) {
		return (keyCard.color == stiche.get(stichNumber).getWinner().color) || 
	   (result.getColorAt(stiche.get(stichNumber).getWinner().color) == CONSTANTS.IMPOSSIBLE);
	}

entdeckt. 
Eine Karte die als nicht KeyKarte verändert wird, d.h. deren Color oder Nummernwert auf SURE gesetzt wurde, 
kann durch die Abfrage isColorBlocked() nicht gefunden werden keyCard <- falsch und result(<-SURE) <- IMPOSSIBLE 
natürlich auch falsch und daher kann diese Karte natürlich nie blockiert sein!
Die ausgebesserte Version:

private boolean isColorBlocked(int stichNumber) {
		return (keyCard.color == stiche.get(stichNumber).getWinner().color) || 
	   (result.getColorAt(stiche.get(stichNumber).getWinner().color) != CONSTANTS.POSSIBLE);
	}
	
Bevor wir die nächste Strategie ausprogrammieren, werden wir BasisStichTest "aufräumen".
Statt der Methode test() werden wir eine Strategiemethode runTest() bestehend aus:
defineTest() : definiert den Testfall
setUpTest() : versucht die keyCard richtig zu setzen
testWithRechterFix() : testet wenn der Rechte fix ist, ob der jeweilige Fall vorliegt oder nicht
setTestSpezials():
testPreviousWinners()

einbauen. Die späteren Strategien müssen dann nur mehr jeweilige Methoden überschreiben:
bis jetzt sicher: defineTest() und setTestSpezials().
Wenn alles glatt läuft können die Methoden testWithRechterFix() und testPreviousWinners()
dann einfach übernommen werden.
Damit das klappt müssen die Variablen:
int winnerNewNumberResult, int winnerNewColorResult
zu Objektvariablen werden, die in defineTest() zusammen mit keyCard gesetzt werden und in testWithRechterFix() 
abgefragt werden können.

Hier die neue Version:
import java.util.ArrayList;

public class BasisStichTest implements StichTestInterface {
	
	private Result result;
	private ArrayList<Stich> stiche;
	private Card keyCard;
	private int winnerNewNumberResult; 
	private int winnerNewColorResult;
// Konstruktor
	public BasisStichTest(Result result, ArrayList<Stich> stiche) {
		try {
			this.result = result.clone();
		} 
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!"); 
		}	
		this.stiche = stiche;
	}
// Setters und Getters
	public Result getResult() { return result; }
	
	//public void setResult(Result result) { this.result = result; }
	
	public ArrayList<Stich> getStiche() { return stiche; }
	
	//public void setStiche(ArrayList<Stich> stiche) { this.stiche = stiche; }
	
	//public Card getKeyCard() { return keyCard; }
	
	public void setKeyCard(Card keyCard) { this.keyCard = keyCard; }
	
	//public int getWinnerNewNumberResult() { return winnerNewNumberResult; }
	 
	public void setWinnerNewNumberResult(int winnerNewNumberResult) {
		this.winnerNewNumberResult = winnerNewNumberResult;
	}
	
	//public int getWinnerNewColorResult() { return winnerNewColorResult; }
	
	public void setWinnerNewColorResult(int winnerNewColorResult) { 
		this.winnerNewColorResult = winnerNewColorResult;
	}
// Strategiemethoden	
	protected void defineTest() {}
	
	private int setUpTest() {
		if((result.getNumberAt(keyCard.number) == -winnerNewNumberResult) || 
		   (result.getColorAt(keyCard.color) == -winnerNewColorResult)) return CONSTANTS.IMPOSSIBLE;
		else {
			result.setNumberAt(keyCard.number,winnerNewNumberResult);
			result.setColorAt(keyCard.color,winnerNewColorResult);
			return CONSTANTS.POSSIBLE;
		}
	}
	
	private int testWithRechterFix() {
		if(!result.isRechterFix()) return CONSTANTS.POSSIBLE;
		if((result.getNumberAt(keyCard.number) == winnerNewNumberResult) && 
		   (result.getColorAt(keyCard.color) == -winnerNewColorResult)) return CONSTANTS.SURE;
		else return CONSTANTS.IMPOSSIBLE;
	}
	
	protected int setTestSpezials() { return CONSTANTS.POSSIBLE; }
	
	private int testPreviousWinners() {
		for(int stichNumber = 0; stichNumber < stiche.size(); stichNumber++) {
			if(findWinner(stichNumber) != stiche.get(stichNumber).winner) 
				if(!correctWinner(stichNumber)) 
					return CONSTANTS.IMPOSSIBLE;
		}
		return CONSTANTS.POSSIBLE;
	}
// runTest
	public int runTest() {
		defineTest();
		if(setUpTest() != CONSTANTS.POSSIBLE) return setUpTest();
		if(testWithRechterFix() != CONSTANTS.POSSIBLE) return testWithRechterFix();
		if(setTestSpezials() != CONSTANTS.POSSIBLE) return setTestSpezials();
		if(testPreviousWinners() != CONSTANTS.POSSIBLE) return testPreviousWinners();
		return CONSTANTS.POSSIBLE;
	}
// private Testmethoden
	// public fürs Testen
	public int findWinner(int stichNumber) {
		int currentWinnerPosition = 0;
		for(int cardNumber = 1; cardNumber < stiche.get(stichNumber).cards.length; cardNumber++) 
			if(!(new CardRelation(stiche.get(stichNumber).cards[currentWinnerPosition],result).beats(new CardRelation(stiche.get(stichNumber).cards[cardNumber],result)))) 
				currentWinnerPosition = cardNumber;
		return currentWinnerPosition;
	}

	private boolean correctWinner(int stichNumber) { 
		if((correctColor(stichNumber) == CONSTANTS.IMPOSSIBLE) &&
		   (correctNumber(stichNumber) == CONSTANTS.IMPOSSIBLE) &&
		   (correctToGuater(stichNumber) == CONSTANTS.IMPOSSIBLE))
		{
			System.out.println("Stich Nr.: " + stichNumber + " weder Trumpf noch Schlag könnten erhöht werden!");
			return false;
		}
		return true;
	}
	
	private int correctColor(int stichNumber) {
		System.out.println("correctColor in: " + stichNumber);
		int testValueColorUp = CONSTANTS.POSSIBLE;
		try {
			if(!isColorBlocked(stichNumber)) {
				Result saveResult = result.clone();
				result.setColorAt(stiche.get(stichNumber).getWinner().color,CONSTANTS.SURE);
				testValueColorUp = testPreviousWinners();
				result = saveResult;
				System.out.println("Stich Nr.: " + stichNumber + " corrected Color: " + stiche.get(stichNumber).getWinner().color);
			} 
			else testValueColorUp = CONSTANTS.IMPOSSIBLE;
		} 
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!");
		}
		return testValueColorUp;
	}
	
	private boolean isColorBlocked(int stichNumber) {
		return (keyCard.color == stiche.get(stichNumber).getWinner().color) || 
	   (result.getColorAt(stiche.get(stichNumber).getWinner().color) != CONSTANTS.POSSIBLE);
	}
	
	private int correctNumber(int stichNumber) {
		System.out.println("correctNumber in: " + stichNumber);
		int testValueNumberUp = CONSTANTS.POSSIBLE;
		try {
			if(!isNumberBlocked(stichNumber)) {
				Result saveResult = result.clone();
				result.setNumberAt(stiche.get(stichNumber).getWinner().number,CONSTANTS.SURE);
				testValueNumberUp = testPreviousWinners();
				result = saveResult;
				System.out.println("Stich Nr.: " + stichNumber + " corrected Number: " + stiche.get(stichNumber).getWinner().number);
			}
			else testValueNumberUp = CONSTANTS.IMPOSSIBLE;
		} 
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!");
		}
		return testValueNumberUp;
	}
	
	private boolean isNumberBlocked(int stichNumber) {
		return (keyCard.number == stiche.get(stichNumber).getWinner().number) || 
	   (result.getNumberAt(stiche.get(stichNumber).getWinner().number) != CONSTANTS.POSSIBLE);
	}
	
	private int correctToGuater(int stichNumber) {
		System.out.println("correctToGuater in: " + stichNumber);
		if(!result.getMitGuatem()) return CONSTANTS.IMPOSSIBLE;
		int testGuaterUp = CONSTANTS.POSSIBLE;
		try {
			if(!isColorBlocked(stichNumber) && 
	           (result.getNumberAt(stiche.get(stichNumber).getWinner().getPreviousNumberCard().number) != CONSTANTS.IMPOSSIBLE)) {
				Result saveResult = result.clone();
				result.setColorAt(stiche.get(stichNumber).getWinner().color,CONSTANTS.SURE);
				result.setNumberAt(stiche.get(stichNumber).getWinner().getPreviousNumberCard().number,CONSTANTS.SURE);
				testGuaterUp = testPreviousWinners();
				result = saveResult;
				System.out.println("Stich Nr.: " + stichNumber); 
				System.out.println("corrected Color: " + stiche.get(stichNumber).getWinner().color);
				System.out.println("corrected Number: " + stiche.get(stichNumber).getWinner().getPreviousNumberCard().number);
			}
			else testGuaterUp = CONSTANTS.IMPOSSIBLE;
		}
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!");
		}
		return testGuaterUp;
	}
}

und 
 
import java.util.ArrayList;

public class FarbStichTest extends BasisStichTest {
 
	public FarbStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	protected void defineTest() {
		super.defineTest();
		setKeyCard(getStiche().get(getStiche().size() - 1).getWinner());
		setWinnerNewNumberResult(CONSTANTS.IMPOSSIBLE);
		setWinnerNewColorResult(CONSTANTS.IMPOSSIBLE);
	}
	
	public int setTestSpezials() { return setAllColorsInLastStichToImpossible(); }
	
	private int setAllColorsInLastStichToImpossible() {
		for(int position = 0; position < getStiche().get(getStiche().size()-1).cards.length; position++) {
			if(getResult().getColorAt(getStiche().get(getStiche().size()-1).cards[position].color) == CONSTANTS.SURE) 
				return CONSTANTS.IMPOSSIBLE; 
			else 
				getResult().setColorAt(getStiche().get(getStiche().size()-1).cards[position].color,CONSTANTS.IMPOSSIBLE);
		}
		return CONSTANTS.POSSIBLE;
	}
	
	public int test() {
		return runTest();
	}
}

Der neu hinzugefügte Test:

	public void test_runTest_Rechter_is_Fix() {
		System.out.println("Rechter_is_Fix_Tests Nr. 1");
		// Rechter: hK
		Result result = new Result(true);
		result.setNumberAt(CONSTANTS.KOENIG,CONSTANTS.SURE);
		result.setColorAt(CONSTANTS.HERZ,CONSTANTS.SURE);
		stiche.clear();
		stiche.add(new Stich(e7, lA, l7, e8, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.SURE, new FarbStichTest(result, stiche).runTest());
	}
}

zeigt einen Fehler in:

private int testWithRechterFix() {
		if(!result.isRechterFix()) return CONSTANTS.POSSIBLE;
		if((result.getNumberAt(keyCard.number) == winnerNewNumberResult) && 
		   (result.getColorAt(keyCard.color) == -winnerNewColorResult)) return CONSTANTS.SURE;
		else return CONSTANTS.IMPOSSIBLE;
	}
 
-winnerNewColorResult: das - wurde beim Kopieren vergessen.

zum Testen der Fälle, wenn der Rechte bereits feststeht wurden folgende Testfälle hinzugefügt:

	public void test_runTest_Rechter_is_Fix() {
		System.out.println("Rechter_is_Fix_Tests Nr. 1");
		// Rechter: hK
		Result result = new Result(true);
		result.setNumberAt(CONSTANTS.KOENIG,CONSTANTS.SURE);
		result.setColorAt(CONSTANTS.HERZ,CONSTANTS.SURE);
		stiche.clear();
		stiche.add(new Stich(e7, lA, l7, e8, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.SURE, new FarbStichTest(result, stiche).runTest());
		stiche.add(new Stich(e10, eA, hK, hO, 2));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		stiche.add(new Stich(s6, hU, lO, s7, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		stiche.add(new Stich(lA, lK, l10, eU, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
	}
}

TrumpfStichTest läßt sich nun recht einfach implementieren:

import java.util.ArrayList;

public class TrumpfStichTest extends BasisStichTest {
 
	public TrumpfStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	protected void defineTest() {
		super.defineTest();
		setKeyCard(getStiche().get(getStiche().size() - 1).getWinner());
		setWinnerNewNumberResult(CONSTANTS.IMPOSSIBLE);
		setWinnerNewColorResult(CONSTANTS.SURE);
	}
}


mit den Tests dazu: (die Tests zu den Farbstichen wurden einfach erweitert)

import java.util.ArrayList;

import junit.framework.TestCase;

public class Test_TrumpfStichTest extends TestCase {

	Card hA, hK, hO, hU, h10, h9, h8, h7;

	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;

	Card eA, eK, eO, eU, e10, e9, e8, e7;

	Card lA, lK, lO, lU, l10, l9, l8, l7;

	ArrayList<Stich> stiche;

	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);

		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);

		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);

		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);

		stiche = new ArrayList<Stich>(5);
	}

	public void test_runTest_erster_Stich_Trumpfstich() {
		Result result = new Result(false);

		stiche.add(new Stich(e7, h7, l7, e9, 3));
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		
		stiche.clear();
		stiche.add(new Stich(e7, h7, l7, e9, 0));
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());

		stiche.clear();
		result = new Result(false);
		stiche.add(new Stich(e7, h7, l7, e9, 1));
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
	}
	
	public void test_runTest_serien_runTests() {
		System.out.println();
		System.out.println("serien_Tests Nr. 1");
		System.out.println("##########################################################");
		Result result = new Result(true);
		stiche.clear();
		stiche.add(new Stich(e7, hA, l7, e8, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		stiche.add(new Stich(e9, sK, lU, e10, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		
		System.out.println();
		System.out.println("serien_Tests Nr. 2");
		System.out.println("##########################################################");
		result = new Result(true);
		stiche.clear();
		stiche.add(new Stich(e7, hA, l7, e8, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e9, sK, lU, e10, 3));
		result.calcSchlag(stiche);
		System.out.println(result.toString());
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		// ab hier ist das Programm bereits besser als der Programmierer (benötigte Debugger)!
		// wenn e=Trumpf muss hA im ersten Stich linker sein => e7 im erstenStich Guater!
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		
		System.out.println();
		System.out.println("serien_Tests Nr. 3");
		System.out.println("##########################################################");
		result = new Result(true);
		// Idee Rechter: sU
		stiche.clear();
		stiche.add(new Stich(e7, sU, sA, sO, 3));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr. 1");
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e9, sK, lU, e10, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr. 2");
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		
		System.out.println();
		System.out.println("serien_runTests Nr. 4");
		System.out.println("##########################################################");
		result = new Result(true);
		// Idee Rechter: sU
		stiche.clear();
		
		stiche.add(new Stich(e7, sO, lA, sK, 1));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 0 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e9, sK, sU, e10, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 1 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e8, lK, lU, l8, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 2 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(s6, hK, l7, s10, 3));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 3 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		
	}
	
	public void test_runTest_Rechter_is_Fix() {
		System.out.println("Rechter_is_Fix_Tests Nr. 1");
		// Rechter: hK
		Result result = new Result(true);
		result.setNumberAt(CONSTANTS.KOENIG,CONSTANTS.SURE);
		result.setColorAt(CONSTANTS.HERZ,CONSTANTS.SURE);
		stiche.clear();
		// reiner Farbstich
		stiche.add(new Stich(e7, lA, l7, e8, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.SURE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		// Rechter sticht
		stiche.add(new Stich(e10, eA, hK, hO, 2));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		// Trumpf sticht
		stiche.add(new Stich(s6, hU, lO, s7, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new TrumpfStichTest(result, stiche).runTest());
		// Linker sticht
		stiche.add(new Stich(lA, lK, l10, eU, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
	}
}


Linkerstich läßt sich dann ebenfalls leicht codieren:

import java.util.ArrayList;

public class LinkerStichTest extends BasisStichTest {
 
	public LinkerStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	protected void defineTest() {
		super.defineTest();
		setKeyCard(getStiche().get(getStiche().size() - 1).getWinner());
		setWinnerNewNumberResult(CONSTANTS.SURE);
		setWinnerNewColorResult(CONSTANTS.IMPOSSIBLE);
	}
}

und den Tests dazu:


import java.util.ArrayList;

import junit.framework.TestCase;

public class Test_LinkerStichTest extends TestCase {

	Card hA, hK, hO, hU, h10, h9, h8, h7;

	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;

	Card eA, eK, eO, eU, e10, e9, e8, e7;

	Card lA, lK, lO, lU, l10, l9, l8, l7;

	ArrayList<Stich> stiche;

	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);

		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);

		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);

		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);

		stiche = new ArrayList<Stich>(5);
	}

	public void test_runTest_erster_Stich_Linkerstich() {
		Result result = new Result(false);

		stiche.add(new Stich(e7, h7, l7, e9, 3));
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		
		stiche.clear();
		stiche.add(new Stich(e7, h7, l7, e9, 0));
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());

		stiche.clear();
		result = new Result(false);
		stiche.add(new Stich(e7, h7, l7, e9, 1));
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
	}
	
	public void test_runTest_serien_runTests() {
		System.out.println();
		System.out.println("serien_Tests Nr. 1");
		System.out.println("##########################################################");
		Result result = new Result(true);
		stiche.clear();
		stiche.add(new Stich(e7, hA, l7, e8, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		stiche.add(new Stich(e9, sK, lU, e10, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		
		System.out.println();
		System.out.println("serien_Tests Nr. 2");
		System.out.println("##########################################################");
		result = new Result(true);
		stiche.clear();
		stiche.add(new Stich(e7, hA, l7, e8, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e9, sK, lU, e10, 3));
		result.calcSchlag(stiche);
		System.out.println(result.toString());
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		// ab hier ist das Programm bereits besser als der Programmierer (benötigte Debugger)!
		// wenn e=Trumpf muss hA im ersten Stich linker sein => e7 im erstenStich Guater!
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		
		System.out.println();
		System.out.println("serien_Tests Nr. 3");
		System.out.println("##########################################################");
		result = new Result(true);
		// Idee Rechter: sU
		stiche.clear();
		stiche.add(new Stich(e7, sU, sA, sO, 3));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr. 1");
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e9, sK, lU, e10, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr. 2");
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		
		System.out.println();
		System.out.println("serien_runTests Nr. 4");
		System.out.println("##########################################################");
		result = new Result(true);
		// Idee Rechter: sU
		stiche.clear();
		
		stiche.add(new Stich(e7, sO, lA, sK, 1));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 0 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e9, sK, sU, e10, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 1 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e8, lK, lU, l8, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 2 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(s6, hK, l7, s10, 3));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 3 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
	
	}
	
	public void test_runTest_Rechter_is_Fix() {
		System.out.println("Rechter_is_Fix_Tests Nr. 1");
		// Rechter: hK
		Result result = new Result(true);
		result.setNumberAt(CONSTANTS.KOENIG,CONSTANTS.SURE);
		result.setColorAt(CONSTANTS.HERZ,CONSTANTS.SURE);
		stiche.clear();
		// reiner Farbstich
		stiche.add(new Stich(e7, lA, l7, e8, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.SURE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		// Rechter sticht
		stiche.add(new Stich(e10, eA, hK, hO, 2));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		// Trumpf sticht
		stiche.add(new Stich(s6, hU, lO, s7, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		// Linker sticht
		stiche.add(new Stich(lA, lK, l10, eU, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new LinkerStichTest(result, stiche).runTest());
	}
}

Leider gibts in RechterStichTest wieder Probleme:
Der Rechte ist nun fix. Daher wird in setUpTest() SURE zurückgeliefert und es wird nicht mehr weiter 
nach previousWinners() gesucht!
Dieser Fall muss irgendwo abgefangen werden.

Durch Vertauschen der Fälle in runTest() läßt sich dieses Problem lösen:
Jetzt werden zuerst die Fälle mit fixem Rechten abgehandelt und dann erst setUpTest(), das sinnvollerweise 
gleich in setUpResult() umbenannt wurde.

	public int runTest() {
		defineTest();
		//if(setUpTest() != CONSTANTS.POSSIBLE) return setUpTest();
		if(testWithRechterFix() != CONSTANTS.POSSIBLE) return testWithRechterFix();
		if(setUpResult() != CONSTANTS.POSSIBLE) return setUpResult();
		if(setTestSpezials() != CONSTANTS.POSSIBLE) return setTestSpezials();
		if(testPreviousWinners() != CONSTANTS.POSSIBLE) return testPreviousWinners();
		return CONSTANTS.POSSIBLE;
	}

Das nächste Problem taucht beim Testen zu Rechter Stich auf:

In 

	public void test_runTest_Rechter_is_Fix() {
		System.out.println("Rechter_is_Fix_Tests Nr. 1");
		// Rechter: hK
		Result result = new Result(true);
		result.setNumberAt(CONSTANTS.KOENIG,CONSTANTS.SURE);
		result.setColorAt(CONSTANTS.HERZ,CONSTANTS.SURE);
		stiche.clear();
		// reiner Farbstich
		stiche.add(new Stich(e7, lA, l7, e8, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.SURE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		// Rechter sticht
		stiche.add(new Stich(e10, eA, hK, hO, 2));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new RechterStichTest(result, stiche).runTest());
		// Trumpf sticht
		stiche.add(new Stich(s6, hU, lO, s7, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		// Linker sticht
		stiche.add(new Stich(sA, lK, l10, eU, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		// Guater sticht
		stiche.add(new Stich(e9, sU, hA, h10, 2));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
->		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
	}

Im obigen Test scheitert:
assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
denn ein Trumpfstich wird als SURE erkannt.
Die As erfüllt als Guater natürlich alle Eigenschaften eines Trumpfes, der sticht.
Der Fall, dass ein Trumpf der Guate ist, muss deshalb in testWithRechterFix() extra abgefragt werden.
Daher hier die korigierte Version:

private int testWithRechterFix() {
		if(!result.isRechterFix()) return CONSTANTS.POSSIBLE;  // Rechter noch nicht fix, daher ist alles noch möglich
		if(isGuaterInTrumpfStichTest()) return CONSTANTS.IMPOSSIBLE;
		if(isWinnerCardFittingAnOtherStichTest()) return CONSTANTS.SURE;
		else return CONSTANTS.IMPOSSIBLE;
	}
	
	private boolean isGuaterInTrumpfStichTest() {
		return winnerNewNumberResult == CONSTANTS.IMPOSSIBLE && 
			   winnerNewColorResult == CONSTANTS.SURE && 
			   result.getGuater().equals(keyCard);
	}
	private boolean isWinnerCardFittingAnOtherStichTest() { // Farbe, Trump
		return ((result.getNumberAt(keyCard.number) == winnerNewNumberResult) && 
		        (result.getColorAt(keyCard.color) == winnerNewColorResult));
	}

GuaterStichTest läßt sich dann recht einfach implementieren:
Für den Guaten wird einfach der zugehörige Rechte durchgreicht. 

In testWithRechterFix() funktioniert deswegen alles weil:
FarbStichTest und LinkerStichTest sowieso funktionieren,
im TrumpfStichTest wird der Fall, dass der Trumpf der Guate ist extra behandelt. Damit funktioniert
auch TrumpfStichTest.
RechterStichTest funktioniert ganz normal und in GuaterStichTest reicht auf RechterStichTest durch.
In guater

import java.util.ArrayList;

public class GuaterStichTest extends BasisStichTest {
 
	public GuaterStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	protected void defineTest() {
		super.defineTest();
		setKeyCard(getStiche().get(getStiche().size() - 1).getWinner().getPreviousNumberCard());
		setWinnerNewNumberResult(CONSTANTS.SURE);
		setWinnerNewColorResult(CONSTANTS.SURE);
	}
	
	protected int setTestSpezials() { 
		if(getResult().isMitGuatem()) return CONSTANTS.POSSIBLE;
		else return CONSTANTS.IMPOSSIBLE;
	}
}


und die Test funktionieren auch:

import java.util.ArrayList;

import junit.framework.TestCase;

public class Test_GuaterStichTest extends TestCase {

	Card hA, hK, hO, hU, h10, h9, h8, h7;

	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;

	Card eA, eK, eO, eU, e10, e9, e8, e7;

	Card lA, lK, lO, lU, l10, l9, l8, l7;

	ArrayList<Stich> stiche;

	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);

		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);

		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);

		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);

		stiche = new ArrayList<Stich>(5);
	}

	public void test_runTest_erster_Stich_Rechterstich() {
		Result result = new Result(false);

		stiche.add(new Stich(e7, h7, l7, e9, 3));
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());

		stiche.clear();
		result = new Result(true);
		stiche.add(new Stich(e7, h7, l7, e9, 3));
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
	}
	
	public void test_runTest_serien_runTests() {
		System.out.println();
		System.out.println("serien_Tests Nr. 1");
		System.out.println("##########################################################");
		Result result = new Result(true);
		stiche.clear();
		stiche.add(new Stich(e7, hA, l7, e8, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		stiche.add(new Stich(e9, sK, lU, e10, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		
		System.out.println();
		System.out.println("serien_Tests Nr. 2");
		System.out.println("##########################################################");
		result = new Result(true);
		stiche.clear();
		stiche.add(new Stich(e7, hA, l7, e8, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e9, sK, lU, e10, 3));
		result.calcSchlag(stiche);
		System.out.println(result.toString());
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		// ab hier ist das Programm bereits besser als der Programmierer (benötigte Debugger)!
		// wenn e=Trumpf muss hA im ersten Stich linker sein => e7 im erstenStich Guater!
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		
		System.out.println();
		System.out.println("serien_Tests Nr. 3");
		System.out.println("##########################################################");
		result = new Result(true);
		// Idee Rechter: sU
		stiche.clear();
		stiche.add(new Stich(e7, sU, sA, sO, 3));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr. 1");
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e9, sK, lU, e10, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr. 2");
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		
		System.out.println();
		System.out.println("serien_runTests Nr. 4");
		System.out.println("##########################################################");
		result = new Result(true);
		// Idee Rechter: sU
		stiche.clear();
		
		stiche.add(new Stich(e7, sO, lA, sK, 1));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 0 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e9, sA, sU, e10, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 1 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e8, lK, lU, l8, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 2 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(s6, hK, l7, s10, 3));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 3 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
	
	}
	
	public void test_runTest_Rechter_is_Fix() {
		System.out.println("Rechter_is_Fix_Tests Nr. 1");
		// Rechter: hK
		Result result = new Result(true);
		result.setNumberAt(CONSTANTS.KOENIG,CONSTANTS.SURE);
		result.setColorAt(CONSTANTS.HERZ,CONSTANTS.SURE);
		stiche.clear();
		// reiner Farbstich
		stiche.add(new Stich(e7, lA, l7, e8, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.SURE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		// Rechter sticht
		stiche.add(new Stich(e10, eA, hK, hO, 2));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		// Trumpf sticht
		stiche.add(new Stich(s6, hU, lO, s7, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		// Linker sticht
		stiche.add(new Stich(sA, lK, l10, eU, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		// Guater sticht
		stiche.add(new Stich(e9, sU, hA, h10, 2));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new GuaterStichTest(result, stiche).runTest());
	}
	
}

beim genaueren hinschauen, fällt aber auf, dass der Fall 

System.out.println("Stich Nr.: 3 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		
völlig unlogisch ist. Laut Annahme sK Rechter, müsste das ein Trumpfstich sein!
Da liegt der Hund wohl im Test selbst begraben, denn das hätte schon in Test_TrumpStichTest() auffallen 
müssen!
Hier muss noch ein Fehler gesucht und behoben werden.

Positiv jedoch folgende Überlegung aus den Stichen davor:

		stiche.add(new Stich(e9, sA, sU, e10, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 1 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		
		stiche.add(new Stich(e8, lK, lU, l8, 2));
		result.calcSchlag(stiche);
		System.out.println("Stich Nr.: 2 -----------------------");
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
 
Wenn nur mehr eine Möglichkeit als POSSIBLE über bleibt, dann kann diese wohl auf SURE gesetzt werden?

Zurück zu Test_TrumpStichTest() um den Fehler zu beheben.
Der Fehler dürfte darin liegen, dass der Guate nicht hergestellt werden kann wenn die Color blockiert ist.
Das ist aber auch dann der Fall, wenn die Farbe bereits den richtigen Wert hat!
Es  fragt sich weiters, ob das auch sonst Auswirkungen hat?

private boolean isColorBlocked(int stichNumber) {
		return (keyCard.color == stiche.get(stichNumber).getWinner().color) || 
	   (result.getColorAt(stiche.get(stichNumber).getWinner().color) != CONSTANTS.POSSIBLE);
	}
	
Es scheint eine Methode isGuaterBlocked() notwendig zu sein. 
Weiters fällt auf, dass in isColorBlocked() und isNumberBlocked() zuerst nach der Farbe bzw. dem Schlag 
der keyCard abgefragt wird. Bei einer keyCard sollte hier im zugehörigen Result immer IMPOSSIBLE oder SURE stehen.
Das heißt die zweite Abfrage alleine sollte ausreichen!
Das testen wir zuerst, bevor wir zu isGuaterBlocked() schreiten.
Die Tests bestätigen, dass die Abfragen hier vereinfacht werden können.

private boolean isColorBlocked(int stichNumber) {
		return (result.getColorAt(stiche.get(stichNumber).getWinner().color) != CONSTANTS.POSSIBLE);
	}

Diesen Einzeiler können wir nun wieder direkt in die if - Abfrage zurücktransformieren!
if(result.getColorAt(stiche.get(stichNumber).getWinner().color) == CONSTANTS.POSSIBLE) {

und natürlich wieder testen

Anschließend hat sich isGuaterBlocked() in folgendes verwandelt:

	private boolean isGuaterUpgradePossible(int stichNumber) {
		// keyCard selbst darf nicht verändert werden, da sie ja den Testfall definiert!
		if(isKeyCardWinnerCardForUpgrade(stichNumber)) return false;
		if(isNotColorAndNumberBlocked(stichNumber) && isColorOrNumberPossible(stichNumber))
			return true;
		else return false;
	}
	
	private boolean isKeyCardWinnerCardForUpgrade(int stichNumber) {
		return ((keyCard.color == stiche.get(stichNumber).getWinner().color) && 
				   (keyCard.number == stiche.get(stichNumber).getWinner().number));
	}
	
	private boolean isNotColorAndNumberBlocked(int stichNumber) {
		// in Result: (¬-1 && ¬-1) &&  (0 || 0)
		return ((result.getColorAt(stiche.get(stichNumber).getWinner().color) != CONSTANTS.IMPOSSIBLE) &&
				(result.getNumberAt(stiche.get(stichNumber).getWinner().getPreviousNumberCard().number) != CONSTANTS.IMPOSSIBLE));
	}
	
	private boolean isColorOrNumberPossible(int stichNumber) {
		return ((result.getColorAt(stiche.get(stichNumber).getWinner().color) == CONSTANTS.POSSIBLE) ||
				(result.getNumberAt(stiche.get(stichNumber).getWinner().getPreviousNumberCard().number) == CONSTANTS.POSSIBLE));
	}

allerdings wurden die letzten 3 Methoden zuerst als Abfragen in isGuaterUpgradePossible() realisiert und erst 
dann der Übersicht wegen herausfraktioniert!
und 

	private int correctToGuater(int stichNumber) {
		if(VERBOSE) System.out.println("entering correctToGuater in Stichnumber : " + stichNumber);
		if(!result.isMitGuatem()) return CONSTANTS.IMPOSSIBLE;
		int testGuaterUp = CONSTANTS.POSSIBLE;
		try {
			if(isGuaterUpgradePossible(stichNumber)) {
				Result saveResult = result.clone();
				result.setColorAt(stiche.get(stichNumber).getWinner().color,CONSTANTS.SURE);
				result.setNumberAt(stiche.get(stichNumber).getWinner().getPreviousNumberCard().number,CONSTANTS.SURE);
				testGuaterUp = testPreviousWinners();
				result = saveResult;
				if(VERBOSE) {
					System.out.println("Stich Nr.: " + stichNumber); 
					System.out.println("corrected Color: " + stiche.get(stichNumber).getWinner().color);
					System.out.println("corrected Number: " + stiche.get(stichNumber).getWinner().getPreviousNumberCard().number);
				}
			}
			else testGuaterUp = CONSTANTS.IMPOSSIBLE;
		}
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!");
		}
		return testGuaterUp;
	}

und damit alle Stichetests wie folgt:

import java.util.ArrayList;

public class BasisStichTest implements StichTestInterface {
	
	private final boolean VERBOSE = true;
	
	private Result result;
	private ArrayList<Stich> stiche;
	private Card keyCard;
	private int winnerNewNumberResult; 
	private int winnerNewColorResult;
// Konstruktor
	public BasisStichTest(Result result, ArrayList<Stich> stiche) {
		try {
			this.result = result.clone();
		} 
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!"); 
		}	
		this.stiche = stiche;
	}
// Setters und Getters
	public Result getResult() { return result; }
	
	//public void setResult(Result result) { this.result = result; }
	
	public ArrayList<Stich> getStiche() { return stiche; }
	
	//public void setStiche(ArrayList<Stich> stiche) { this.stiche = stiche; }
	
	//public Card getKeyCard() { return keyCard; }
	
	public void setKeyCard(Card keyCard) { this.keyCard = keyCard; }
	
	//public int getWinnerNewNumberResult() { return winnerNewNumberResult; }
	 
	public void setWinnerNewNumberResult(int winnerNewNumberResult) {
		this.winnerNewNumberResult = winnerNewNumberResult;
	}
	
	//public int getWinnerNewColorResult() { return winnerNewColorResult; }
	
	public void setWinnerNewColorResult(int winnerNewColorResult) { 
		this.winnerNewColorResult = winnerNewColorResult;
	}
// Strategiemethoden	
	protected void defineTest() {}
	
	private int setUpResult() {
		if((result.getNumberAt(keyCard.number) == -winnerNewNumberResult) || 
		   (result.getColorAt(keyCard.color) == -winnerNewColorResult)) return CONSTANTS.IMPOSSIBLE;
		else {
			result.setNumberAt(keyCard.number,winnerNewNumberResult);
			result.setColorAt(keyCard.color,winnerNewColorResult);
			return CONSTANTS.POSSIBLE;
		}
	}
	
	private int testWithRechterFix() {
		if(!result.isRechterFix()) return CONSTANTS.POSSIBLE;  // Rechter noch nicht fix, daher ist alles noch möglich
		if(isGuaterInTrumpfStichTest()) return CONSTANTS.IMPOSSIBLE;
		if(isWinnerCardFittingAnOtherStichTest()) return CONSTANTS.SURE;
		else return CONSTANTS.IMPOSSIBLE;
	}
	
	private boolean isGuaterInTrumpfStichTest() {
		return winnerNewNumberResult == CONSTANTS.IMPOSSIBLE && 
			   winnerNewColorResult == CONSTANTS.SURE && 
			   result.getGuater().equals(keyCard);
	}
	private boolean isWinnerCardFittingAnOtherStichTest() { // Farbe, Trump
		return ((result.getNumberAt(keyCard.number) == winnerNewNumberResult) && 
		        (result.getColorAt(keyCard.color) == winnerNewColorResult));
	}
	
	protected int setTestSpezials() { return CONSTANTS.POSSIBLE; }
	
	private int testPreviousWinners() {
		for(int stichNumber = 0; stichNumber < stiche.size(); stichNumber++) {
			if(findWinner(stichNumber) != stiche.get(stichNumber).winner) 
				if(!correctWinner(stichNumber)) 
					return CONSTANTS.IMPOSSIBLE;
		}
		return CONSTANTS.POSSIBLE;
	}
// runTest
	public int runTest() {
		defineTest();
		//if(setUpTest() != CONSTANTS.POSSIBLE) return setUpTest();
		if(testWithRechterFix() != CONSTANTS.POSSIBLE) return testWithRechterFix();
		if(setUpResult() != CONSTANTS.POSSIBLE) return setUpResult();
		if(setTestSpezials() != CONSTANTS.POSSIBLE) return setTestSpezials();
		//if(setUpResult() != CONSTANTS.POSSIBLE) return setUpResult();
		if(testPreviousWinners() != CONSTANTS.POSSIBLE) return testPreviousWinners();
		return CONSTANTS.POSSIBLE;
	}
// private Testmethoden
	// public fürs Testen
	public int findWinner(int stichNumber) {
		int currentWinnerPosition = 0;
		for(int cardNumber = 1; cardNumber < stiche.get(stichNumber).cards.length; cardNumber++) 
			if(!(new CardRelation(stiche.get(stichNumber).cards[currentWinnerPosition],result).beats(new CardRelation(stiche.get(stichNumber).cards[cardNumber],result)))) 
				currentWinnerPosition = cardNumber;
		return currentWinnerPosition;
	}

	private boolean correctWinner(int stichNumber) { 
		if((correctColor(stichNumber) == CONSTANTS.IMPOSSIBLE) &&
		   (correctNumber(stichNumber) == CONSTANTS.IMPOSSIBLE) &&
		   (correctToGuater(stichNumber) == CONSTANTS.IMPOSSIBLE))
		{
			if(VERBOSE) System.out.println("Stich Nr.: " + stichNumber + " weder Trumpf noch Schlag könnten erhöht werden!");
			return false;
		}
		return true;
	}
	
	private int correctColor(int stichNumber) {
		if(VERBOSE) System.out.println("entering correctColor in Stichnumber : " + stichNumber);
		int testValueColorUp = CONSTANTS.POSSIBLE;
		try {
			if(result.getColorAt(stiche.get(stichNumber).getWinner().color) == CONSTANTS.POSSIBLE) {
				Result saveResult = result.clone();
				result.setColorAt(stiche.get(stichNumber).getWinner().color,CONSTANTS.SURE);
				testValueColorUp = testPreviousWinners();
				result = saveResult;
				System.out.println("Stich Nr.: " + stichNumber + " corrected Color: " + stiche.get(stichNumber).getWinner().color);
			} 
			else testValueColorUp = CONSTANTS.IMPOSSIBLE;
		} 
		catch(CloneNotSupportedException e) {
			if(VERBOSE) System.out.println("Result konnte nicht geklont werden!");
		}
		return testValueColorUp;
	}
	
	private int correctNumber(int stichNumber) {
		if(VERBOSE) System.out.println("entering correctNumber in Stichnumber : " + stichNumber);
		int testValueNumberUp = CONSTANTS.POSSIBLE;
		try {
			if(result.getNumberAt(stiche.get(stichNumber).getWinner().number) == CONSTANTS.POSSIBLE) {
				Result saveResult = result.clone();
				result.setNumberAt(stiche.get(stichNumber).getWinner().number,CONSTANTS.SURE);
				testValueNumberUp = testPreviousWinners();
				result = saveResult;
				if(VERBOSE) System.out.println("Stich Nr.: " + stichNumber + " corrected Number: " + stiche.get(stichNumber).getWinner().number);
			}
			else testValueNumberUp = CONSTANTS.IMPOSSIBLE;
		} 
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!");
		}
		return testValueNumberUp;
	}
	
	private int correctToGuater(int stichNumber) {
		if(VERBOSE) System.out.println("entering correctToGuater in Stichnumber : " + stichNumber);
		if(!result.isMitGuatem()) return CONSTANTS.IMPOSSIBLE;
		int testGuaterUp = CONSTANTS.POSSIBLE;
		try {
			if(isGuaterUpgradePossible(stichNumber)) {
				Result saveResult = result.clone();
				result.setColorAt(stiche.get(stichNumber).getWinner().color,CONSTANTS.SURE);
				result.setNumberAt(stiche.get(stichNumber).getWinner().getPreviousNumberCard().number,CONSTANTS.SURE);
				testGuaterUp = testPreviousWinners();
				result = saveResult;
				if(VERBOSE) {
					System.out.println("Stich Nr.: " + stichNumber); 
					System.out.println("corrected Color: " + stiche.get(stichNumber).getWinner().color);
					System.out.println("corrected Number: " + stiche.get(stichNumber).getWinner().getPreviousNumberCard().number);
				}
			}
			else testGuaterUp = CONSTANTS.IMPOSSIBLE;
		}
		catch(CloneNotSupportedException e) {
			System.out.println("Result konnte nicht geklont werden!");
		}
		return testGuaterUp;
	}
	
	private boolean isGuaterUpgradePossible(int stichNumber) {
		// keyCard selbst darf nicht verändert werden, da sie ja den Testfall definiert!
		if(isKeyCardWinnerCardForUpgrade(stichNumber)) return false;
		if(isNotColorAndNumberBlocked(stichNumber) && isColorOrNumberPossible(stichNumber))
			return true;
		else return false;
	}
	
	private boolean isKeyCardWinnerCardForUpgrade(int stichNumber) {
		return ((keyCard.color == stiche.get(stichNumber).getWinner().color) && 
				   (keyCard.number == stiche.get(stichNumber).getWinner().number));
	}
	
	private boolean isNotColorAndNumberBlocked(int stichNumber) {
		// in Result: (¬-1 && ¬-1) &&  (0 || 0)
		return ((result.getColorAt(stiche.get(stichNumber).getWinner().color) != CONSTANTS.IMPOSSIBLE) &&
				(result.getNumberAt(stiche.get(stichNumber).getWinner().getPreviousNumberCard().number) != CONSTANTS.IMPOSSIBLE));
	}
	
	private boolean isColorOrNumberPossible(int stichNumber) {
		return ((result.getColorAt(stiche.get(stichNumber).getWinner().color) == CONSTANTS.POSSIBLE) ||
				(result.getNumberAt(stiche.get(stichNumber).getWinner().getPreviousNumberCard().number) == CONSTANTS.POSSIBLE));
	}
	
}


import java.util.ArrayList;

public class FarbStichTest extends BasisStichTest {
 
	public FarbStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	protected void defineTest() {
		super.defineTest();
		setKeyCard(getStiche().get(getStiche().size() - 1).getWinner());
		setWinnerNewNumberResult(CONSTANTS.IMPOSSIBLE);
		setWinnerNewColorResult(CONSTANTS.IMPOSSIBLE);
	}
	
	public int setTestSpezials() { return setAllColorsInLastStichToImpossible(); }
	
	private int setAllColorsInLastStichToImpossible() {
		for(int position = 0; position < getStiche().get(getStiche().size()-1).cards.length; position++) {
			if(getResult().getColorAt(getStiche().get(getStiche().size()-1).cards[position].color) == CONSTANTS.SURE) 
				return CONSTANTS.IMPOSSIBLE; 
			else 
				getResult().setColorAt(getStiche().get(getStiche().size()-1).cards[position].color,CONSTANTS.IMPOSSIBLE);
		}
		return CONSTANTS.POSSIBLE;
	}
}


import java.util.ArrayList;

public class TrumpfStichTest extends BasisStichTest {
 
	public TrumpfStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	protected void defineTest() {
		super.defineTest();
		setKeyCard(getStiche().get(getStiche().size() - 1).getWinner());
		setWinnerNewNumberResult(CONSTANTS.IMPOSSIBLE);
		setWinnerNewColorResult(CONSTANTS.SURE);
	}
}


import java.util.ArrayList;

public class LinkerStichTest extends BasisStichTest {
 
	public LinkerStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	protected void defineTest() {
		super.defineTest();
		setKeyCard(getStiche().get(getStiche().size() - 1).getWinner());
		setWinnerNewNumberResult(CONSTANTS.SURE);
		setWinnerNewColorResult(CONSTANTS.IMPOSSIBLE);
	}
}


mport java.util.ArrayList;

public class RechterStichTest extends BasisStichTest {
 
	public RechterStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	protected void defineTest() {
		super.defineTest();
		setKeyCard(getStiche().get(getStiche().size() - 1).getWinner());
		setWinnerNewNumberResult(CONSTANTS.SURE);
		setWinnerNewColorResult(CONSTANTS.SURE);
	}
}


import java.util.ArrayList;

public class GuaterStichTest extends BasisStichTest {
 
	public GuaterStichTest(Result result, ArrayList<Stich> stiche) {
		super(result,stiche);
	}
	
	protected void defineTest() {
		super.defineTest();
		setKeyCard(getStiche().get(getStiche().size() - 1).getWinner().getPreviousNumberCard());
		setWinnerNewNumberResult(CONSTANTS.SURE);
		setWinnerNewColorResult(CONSTANTS.SURE);
	}
	
	protected int setTestSpezials() { 
		if(getResult().isMitGuatem()) return CONSTANTS.POSSIBLE;
		else return CONSTANTS.IMPOSSIBLE;
	}
}

Und jetzt zur Klasse, die die Testergebnisse sammelt und auswertet.

import java.util.ArrayList;

public class StichCalculator { //implements StichTestInterface {
	
	private ArrayList<Stich> stiche;
	private Result result;
	
	private int farbStich;
	private int trumpfStich;
	private int linkerStich;
	private int rechterStich;
	private int guaterStich;
	private boolean resultChanged;
	
	public StichCalculator(boolean mitGuatem) {
		this.stiche = new ArrayList<Stich>(5);
		this.result = new Result(mitGuatem);
	}
	
	public ArrayList<Stich> getStiche() {return stiche; }
	
	public Result getResult() { return result; }
	
	public void makeMessage() {
		calculateNewResult();
		System.out.println("FarbStich: " + farbStich);
		System.out.println("TrumpStich: " + farbStich);
		System.out.println("LinkerStich: " + linkerStich);
		System.out.println("RechterStich: " + rechterStich);
		System.out.println("GuaterStich: " + guaterStich);
	}

	public void calculateNewResult() {
		resultChanged = false;
		result.calcSchlag(stiche);
		do {
			runTest();
			runRules();
			runExcept4Rules();
		} while(resultChanged);
	}

	private void runTest() {
		farbStich = new FarbStichTest(result,stiche).runTest();
		trumpfStich = new TrumpfStichTest(result,stiche).runTest();
		linkerStich = new LinkerStichTest(result,stiche).runTest();
		rechterStich = new RechterStichTest(result,stiche).runTest();
		guaterStich = new GuaterStichTest(result,stiche).runTest();
	}
	
	private void runRules() {
		if(isTrumpfImpossible()) resultChanged = lastWinnerIsNoTrumpf() || resultChanged;
		if(isSchlagOrGuaterImpossible()) resultChanged = lastWinnerIsNoSchlag() || resultChanged;		
	}
	
	private boolean isTrumpfImpossible() {
		return trumpfStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE;
	}
	
	private boolean isSchlagOrGuaterImpossible() {
		return linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE;
	}
	
	private boolean lastWinnerIsNoTrumpf() {
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.IMPOSSIBLE);
		return true;
	}
	
	private boolean lastWinnerIsNoSchlag() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.IMPOSSIBLE);
		return true;
	}
	
	private void runExcept4Rules() {
		if(justGuaterStichPossible()) resultChanged = lastWinnerIsGuater() || resultChanged;
		if(justRechterStichPossible()) resultChanged = lastWinnerIsRechter() || resultChanged;
		if(justLinkerStichPossible()) resultChanged = lastWinnerIsGuater() || resultChanged;
		if(justTrumpfStichPossible()) resultChanged = lastWinnerIsGuater() || resultChanged;
		if(justFarbStichPossible()) resultChanged = lastWinnerIsGuater() || resultChanged;
		
	}
	
	private boolean justGuaterStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && trumpfStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE);
	}
	
	private boolean justRechterStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && trumpfStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE);
	}
	
	private boolean justLinkerStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && trumpfStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE);
	}
	
	private boolean justTrumpfStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE );
	}
	
	private boolean justFarbStichPossible() {
		return (trumpfStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE );
	}
	
	private boolean lastWinnerIsGuater() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().getPreviousNumberCard().number,CONSTANTS.SURE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.SURE);
		return true;
	}
	
	private boolean lastWinnerIsRechter() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.SURE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.SURE);
		return true;
	}
	
	private boolean lastWinnerIsLinker() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.SURE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.IMPOSSIBLE);
		return true;
	}
	
	private boolean lastWinnerIsTrumpf() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.IMPOSSIBLE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.SURE);
		return true;
	}
	
	private boolean lastWinnerIsFarbe() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.IMPOSSIBLE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.IMPOSSIBLE);
		return true;
	}
	
}

Doch kaum ist diese Klasse fertig, zeigt sie auch schon trotz gutem Willen des Programmieres ihre Schwächen:
resultChanged ändert sich auch immer dann, wenn ein bereits von POSSIBLE geänderter Wert erneut geändert wird und 
damit sind die schönsten Voraussetzungen für eine Endlosschleife gegeben.

Auch die offensichtliche "Verbesserung" resultChanged = false; richtigerweise in der Schleife zu platzieren rettet nicht 
vor der Endlosschleife. Au!

public void calculateNewResult() {
		result.calcSchlag(stiche);
		do {
			resultChanged = false;
			runTest();
			runRules();
			runExcept4Rules();
		} while(resultChanged);
	}

Diese zeigt sich bereits im zweiten Testfall:

import java.util.ArrayList;

import junit.framework.TestCase;

public class Test_StichCalculator extends TestCase {

	Card hA, hK, hO, hU, h10, h9, h8, h7;

	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;

	Card eA, eK, eO, eU, e10, e9, e8, e7;

	Card lA, lK, lO, lU, l10, l9, l8, l7;
	
	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);

		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);

		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);

		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);		
	}
	
	public void test_runTest_1() {
		System.out.println();
		System.out.println("serien_Tests Nr. 1");
		System.out.println("##########################################################");
		StichCalculator stichCalculator = new StichCalculator(true);
		ArrayList<Stich> stiche = stichCalculator.getStiche();
		Result result = stichCalculator.getResult();
		stiche.add(new Stich(e7, hA, l7, e8, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		stichCalculator.makeMessage();
		
		stiche.add(new Stich(e9, sK, lU, e10, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		stichCalculator.makeMessage();
	}
	
	public void test_runTest_2() {
		System.out.println();
		System.out.println("serien_Tests Nr. 2");
		System.out.println("##########################################################");
		StichCalculator stichCalculator = new StichCalculator(true);
		ArrayList<Stich> stiche = stichCalculator.getStiche();
		Result result = stichCalculator.getResult();
		stiche.add(new Stich(e7, hA, l7, e8, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		stichCalculator.makeMessage();
		
		stiche.add(new Stich(e9, sK, lU, e10, 3));
		result.calcSchlag(stiche);
		System.out.println(result.toString());
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		// ab hier ist das Programm bereits besser als der Programmierer (benötigte Debugger)!
		// wenn e=Trumpf muss hA im ersten Stich linker sein => e7 im erstenStich Guater!
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		stichCalculator.makeMessage();
	}
}


changeResult ist eigentlich eine Eigenschaft von Result und sollte dort verankert werden.
Vielleicht ist sogar ein Observermuster sinnvoll. Im Hinblick auf eine aktualisierte Darstellung im Grafikmodus 
könnte das sinnvoll sein.

Man kann Observable überhaupt an die Klasse PossibilityArray weiterreichen, da in dieser die Veränderungen
stattfinden.
Es fragt sich dann nur ob Result als Fassade für schlag und trumpf verwendet werden soll?
Wie sollen die Observer an schlag und trumpf durchgereicht werden?
Irgendwie hängt das mit einer späteren Darstellung der PossibilityArrays zusammen. Wie sollen die Daten an die 
grafische Benutzerumgebung weitergereicht werden?
Soll alles mit result.getColorAt() abgefragt werden, oder soll das ganze PossibilityArray durchgereicht werden?
Ein Durchreichen hieße, dass man dann auch mit getSchlagArray().get(1) statt getNumberAt(1) auf die Werte zugreifen könnte!

Um diese Doppelgleisigkeit zu vermeiden werden wir in Result eine Methode addObserverToSchlagAndTrumpf() hinzufügen, 
die die Observer an die PosssibilityArrays durchschleift.
Die PossibilityArrays sollen dann die Klasse Observable erweitern!
So kann evt. später mittels NotifyObservers(hier drinnen dann die Daten) Information an die grafische Oberfläche weitergegeben 
werden.


Hier die geänderten Klassen:

import java.util.Observable;

public class PossibilityArray extends Observable implements Cloneable {
	
	private int[] array;
	
	public PossibilityArray(int size) {
		this.array = new int[size];
	}
	
	public PossibilityArray clone() throws CloneNotSupportedException {
		PossibilityArray tempPossibilityArray = new PossibilityArray(array.length);
		for(int i = 0; i < array.length; i++) tempPossibilityArray.setValueAt(i,array[i]);
		return tempPossibilityArray;
	}
	
	public String toString() {
		StringBuffer tempString = new StringBuffer();
		tempString.append(super.toString());
		tempString.append("\n Values: ");
		for(int i = 0; i < array.length; i++) {
			tempString.append(" v[" + i + "]=" + array[i]);
		}
		return tempString.toString();
	}
	
	public int getLength() { return array.length; }
	
	public void setValueAt(int position, int value) {
		handleObserver(position, value);
		if(value == CONSTANTS.SURE) {
			for(int pos = 0; pos < array.length; pos++) array[pos] = CONSTANTS.IMPOSSIBLE;
			array[position] = value;
		} else {
			array[position] = value;
			correctIfOnePossibleLeft();
		}
	}
	
	private void handleObserver(int position, int value) {
		if(value != array[position]) {
			setChanged();
			notifyObservers(array.clone());
		}
	}
	
	public int get(int position) {
		return array[position];
	}
	
	private void correctIfOnePossibleLeft() {
		int coutZeros = 0;
		int rememberZeroPosition = 0;
		for(int position = 0; position < array.length; position++)
			if(array[position] == CONSTANTS.POSSIBLE) {
				coutZeros++;
				rememberZeroPosition = position;
			}
		if(coutZeros == 1) array[rememberZeroPosition] = CONSTANTS.SURE;
	}

	public int findFirstSure() {
		int position = array.length - 1;
		while(position >= 0 && array[position] != CONSTANTS.SURE) 
			position--;
		return position;
	}
	
}

import java.util.ArrayList;
import java.util.Observer;

public class Result implements Cloneable {
	
	private boolean mitGuatem;
	private PossibilityArray schlag;
	private PossibilityArray trumpf;
	
	public Result(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		schlag = new PossibilityArray(CONSTANTS.ANZAHL_SCHLAEGE);  // alle automatisch auf 0 = POSSIBLE!
		trumpf = new PossibilityArray(CONSTANTS.ANZAHL_FARBEN);    // alle automatisch auf 0 = POSSIBLE!
	}
	
	public Result clone() throws CloneNotSupportedException {
		Result tempResult = new Result(mitGuatem);
		tempResult.setSchlagPossibilityArray(schlag.clone());
		tempResult.setTrumpfPossibilityArray(trumpf.clone());
		return tempResult;
	}

	private void setSchlagPossibilityArray(PossibilityArray schlag) { this.schlag = schlag; }

	private void setTrumpfPossibilityArray(PossibilityArray trumpf) { this.trumpf = trumpf; }
	
	public String toString() {
		StringBuffer tempString = new StringBuffer();
		tempString.append(CONSTANTS.messageColor);
		tempString.append(":\n");
		tempString.append(trumpf.toString());
		tempString.append("\n");
		tempString.append(CONSTANTS.messageNumber);
		tempString.append(":\n");
		tempString.append(schlag.toString());
		return tempString.toString();
	}
	
	public boolean isMitGuatem() { return this.mitGuatem; }
	
	public void setNumberAt(int position, int value) { schlag.setValueAt(position,value); }
	
	public void setColorAt(int position, int value) { trumpf.setValueAt(position,value); }
	
	public int getNumberAt(int position) { return schlag.get(position); }
	
	public int getColorAt(int position) { return trumpf.get(position); }
	
	public int getSchlag() { return schlag.findFirstSure(); }
	
	public int getTrumpf() { return trumpf.findFirstSure(); }
	
	public boolean isSchlagFix() { return getSchlag() != CONSTANTS.IMPOSSIBLE; }
	
	public boolean isTrumpfFix() { return getTrumpf() != CONSTANTS.IMPOSSIBLE; }
	
	public boolean isRechterFix() { return (isSchlagFix() && isTrumpfFix()); }
	
	public boolean isGuaterFix() { return isRechterFix(); }
	
	// getRechter() und getGater() liefern null falls Werte nicht feststehen
	public Card getRechter() { 
		if((getSchlag() == CONSTANTS.IMPOSSIBLE) || getTrumpf() == CONSTANTS.IMPOSSIBLE)
			return null;
		else return new Card(getTrumpf(), getSchlag()); }
	
	public Card getGuater() { 
		if(getRechter() == null) return null;
		else return getRechter().getNextNumberCard(); }
	
	// nicht mehr mögliche Schläge auf IMPOSSIBLE setzen:
	public void calcSchlag(ArrayList<Stich> stiche) {
		setLooserToImpossible(stiche);
		if(mitGuatem) correctPreviousLeftOut(stiche);
	}
	
	public void addObserverToSchlagAndTrumpf(Observer observer) {
		schlag.addObserver(observer);
		trumpf.addObserver(observer);
	}

	private void setLooserToImpossible(ArrayList<Stich> stiche) {
		System.out.println(stiche.size());
		Stich lastStich = stiche.get(stiche.size() - 1);
		for(Card card : lastStich.cards) 
			if(!hasWinnerOrPreviousToWinnerNumber(card, lastStich))
				this.schlag.setValueAt(card.number,CONSTANTS.IMPOSSIBLE);
	}
	
	private boolean hasWinnerOrPreviousToWinnerNumber(Card card, Stich lastStich) {
		// hat selbe Number wie der Winner
		if(card.number == lastStich.getWinner().number) return true;
		// alle Fälle, falls mit dem Guatengespielt wird
		if(mitGuatem) { 
			if(card.number == lastStich.getWinner().getPreviousNumberCard().number)
				return true;
		} 
		return false;
	}
	 
	private void correctPreviousLeftOut(ArrayList<Stich> stiche) {
		for(int stichNumber = 0; stichNumber < stiche.size(); stichNumber++) {
			// winner ist sicher kein Schlag, Rechter oder Guater
			if((schlag.get(stiche.get(stichNumber).getWinner().number) == CONSTANTS.IMPOSSIBLE) &&
			   (trumpf.get(stiche.get(stichNumber).getWinner().color) == CONSTANTS.IMPOSSIBLE))  
						for(Card card : stiche.get(stichNumber).cards) schlag.setValueAt(card.number,CONSTANTS.IMPOSSIBLE);
		}
	}
}


import java.util.ArrayList;
import java.util.Observable;
import java.util.Observer;


public class StichCalculator implements Observer { //implements StichTestInterface {
	
	private ArrayList<Stich> stiche;
	private Result result;
	
	private int farbStich;
	private int trumpfStich;
	private int linkerStich;
	private int rechterStich;
	private int guaterStich;
	private boolean resultChanged;
	
	public StichCalculator(boolean mitGuatem) {
		this.stiche = new ArrayList<Stich>(5);
		this.result = new Result(mitGuatem);
		this.result.addObserverToSchlagAndTrumpf(this);
	}
	
	public void update(Observable observable, Object arg) {
		resultChanged = true;
	}
	
	public ArrayList<Stich> getStiche() {return stiche; }
	
	public Result getResult() { return result; }
	
	public void makeMessage() {
		calculateNewResult();
		System.out.println("FarbStich: " + farbStich);
		System.out.println("TrumpStich: " + farbStich);
		System.out.println("LinkerStich: " + linkerStich);
		System.out.println("RechterStich: " + rechterStich);
		System.out.println("GuaterStich: " + guaterStich);
	}

	public void calculateNewResult() {
		result.calcSchlag(stiche);
		do {
			resultChanged = false;
			runTest();
			runRules();
			runExcept4Rules();
		} while(resultChanged);
	}

	private void runTest() {
		farbStich = new FarbStichTest(result,stiche).runTest();
		trumpfStich = new TrumpfStichTest(result,stiche).runTest();
		linkerStich = new LinkerStichTest(result,stiche).runTest();
		rechterStich = new RechterStichTest(result,stiche).runTest();
		guaterStich = new GuaterStichTest(result,stiche).runTest();
	}
	
	private void runRules() {
		if(isTrumpfImpossible()) lastWinnerIsNoTrumpf();
		if(isSchlagOrGuaterImpossible()) lastWinnerIsNoSchlag();		
	}
	
	private boolean isTrumpfImpossible() {
		return trumpfStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE;
	}
	
	private boolean isSchlagOrGuaterImpossible() {
		return linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE;
	}
	
	private void lastWinnerIsNoTrumpf() {
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.IMPOSSIBLE);
	}
	
	private void lastWinnerIsNoSchlag() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.IMPOSSIBLE);
	}
	
	private void runExcept4Rules() {
		if(justGuaterStichPossible()) lastWinnerIsGuater();
		if(justRechterStichPossible()) lastWinnerIsRechter();
		if(justLinkerStichPossible()) lastWinnerIsGuater();
		if(justTrumpfStichPossible()) lastWinnerIsGuater();
		if(justFarbStichPossible()) lastWinnerIsGuater();
	}
	
	private boolean justGuaterStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && trumpfStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE);
	}
	
	private boolean justRechterStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && trumpfStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE);
	}
	
	private boolean justLinkerStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && trumpfStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE);
	}
	
	private boolean justTrumpfStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE );
	}
	
	private boolean justFarbStichPossible() {
		return (trumpfStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE );
	}
	
	private void lastWinnerIsGuater() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().getPreviousNumberCard().number,CONSTANTS.SURE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.SURE);
	}
	
	private void lastWinnerIsRechter() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.SURE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.SURE);
	}
	
	private void lastWinnerIsLinker() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.SURE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.IMPOSSIBLE);
	}
	
	private void lastWinnerIsTrumpf() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.IMPOSSIBLE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.SURE);
	}
	
	private void lastWinnerIsFarbe() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.IMPOSSIBLE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.IMPOSSIBLE);
	}
	
}

Die Tests in  Test_StichCalculator brachten noch ans Licht, dass in StichCalculator noch ein Kopierfehler vorhanden war:

	private void runExcept4Rules() {
		if(justGuaterStichPossible()) lastWinnerIsGuater();
		if(justRechterStichPossible()) lastWinnerIsRechter();
		if(justLinkerStichPossible()) lastWinnerIsGuater();
		if(justTrumpfStichPossible()) lastWinnerIsGuater();
		if(justFarbStichPossible()) lastWinnerIsGuater();
	}
	
musste natürlich zu:

	private void runExcept4Rules() {
		if(justGuaterStichPossible()) lastWinnerIsGuater();
		if(justRechterStichPossible()) lastWinnerIsRechter();
		if(justLinkerStichPossible()) lastWinnerIsLinker();
		if(justTrumpfStichPossible()) lastWinnerIsTrumpf();
		if(justFarbStichPossible()) lastWinnerIsFarbe();	
	}

verbessert werden.


import java.util.ArrayList;

import watten.CONSTANTS;
import watten.Card;
import watten.FarbStichTest;
import watten.GuaterStichTest;
import watten.LinkerStichTest;
import watten.RechterStichTest;
import watten.Result;
import watten.Stich;
import watten.StichCalculator;
import watten.TrumpfStichTest;


import junit.framework.TestCase;

public class Test_StichCalculator extends TestCase {

	Card hA, hK, hO, hU, h10, h9, h8, h7;

	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;

	Card eA, eK, eO, eU, e10, e9, e8, e7;

	Card lA, lK, lO, lU, l10, l9, l8, l7;
	
	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);

		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);

		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);

		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);		
	}
	
	public void test_runTest_1() {
		System.out.println();
		System.out.println("serien_Tests Nr. 1");
		System.out.println("##########################################################");
		System.out.println();
		System.out.println("Stich Nr. 1");
		System.out.println();
		StichCalculator stichCalculator = new StichCalculator(true);
		ArrayList<Stich> stiche = stichCalculator.getStiche();
		Result result = stichCalculator.getResult();
		stiche.add(new Stich(e7, hA, l7, e8, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		//stichCalculator.makeMessage();
		stichCalculator.calculateNewResult();
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getFarbStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getTrumpfStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getLinkerStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getRechterStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getGuaterStich());
		System.out.println();
		System.out.println("Stich Nr. 2");
		System.out.println();
		stiche.add(new Stich(e9, sK, lU, e10, 3));
		result.calcSchlag(stiche);
		// hier folgt, dass im Falle eines Farbstiches e,s,l keine Trümpfe sein
		// können
		// => h = Trumpf und Widerspruch hA sticht nicht e8
		// e8 muss dann auf linken korrigiert werden!
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		//stichCalculator.makeMessage();
		stichCalculator.calculateNewResult();
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getFarbStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getTrumpfStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getLinkerStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getRechterStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getGuaterStich());
	}
	
	public void test_runTest_2() {
		System.out.println();
		System.out.println("Serien Test Nr. 2");
		System.out.println("##########################################################");
		System.out.println();
		System.out.println("Stich Nr. 1");
		System.out.println();
		StichCalculator stichCalculator = new StichCalculator(true);
		ArrayList<Stich> stiche = stichCalculator.getStiche();
		Result result = stichCalculator.getResult();
		stiche.add(new Stich(e7, hA, l7, e8, 1));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		//stichCalculator.makeMessage();
		stichCalculator.calculateNewResult();
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getFarbStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getTrumpfStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getLinkerStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getRechterStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getGuaterStich());
		System.out.println();
		System.out.println("Stich Nr. 2");
		System.out.println();
		stiche.add(new Stich(e9, sK, lU, e10, 3));
		result.calcSchlag(stiche);
		//System.out.println(result.toString());
		assertEquals(CONSTANTS.POSSIBLE, new FarbStichTest(result, stiche).runTest());
		// ab hier ist das Programm bereits besser als der Programmierer (benötigte Debugger)!
		// wenn e=Trumpf muss hA im ersten Stich linker sein => e7 im erstenStich Guater!
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		//stichCalculator.makeMessage();
		stichCalculator.calculateNewResult();
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getFarbStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getTrumpfStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getLinkerStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getRechterStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getGuaterStich());
	}
	
	public void test_runTest_3() {
		System.out.println();
		System.out.println("Serien Test Nr. 3");
		System.out.println("##########################################################");
		System.out.println();
		StichCalculator stichCalculator = new StichCalculator(true);
		ArrayList<Stich> stiche = stichCalculator.getStiche();
		Result result = stichCalculator.getResult();
		// Idee Rechter: sU
		System.out.println();
		System.out.println("Stich Nr. 1");
		System.out.println();
		stiche.add(new Stich(e7, sU, sA, sO, 3));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		//stichCalculator.makeMessage();
		stichCalculator.calculateNewResult();
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getFarbStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getTrumpfStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getLinkerStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getRechterStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getGuaterStich());
		System.out.println();
		System.out.println("Stich Nr. 2");
		System.out.println();
		stiche.add(new Stich(e9, sK, lU, e10, 2));
		result.calcSchlag(stiche);
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		//stichCalculator.makeMessage();
		stichCalculator.calculateNewResult();
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getFarbStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getTrumpfStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getLinkerStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getRechterStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getGuaterStich());
	}
	
	public void test_runTest_4() {
		System.out.println();
		System.out.println("Serien Test Nr. 4");
		System.out.println("##########################################################");
		System.out.println();
		StichCalculator stichCalculator = new StichCalculator(true);
		ArrayList<Stich> stiche = stichCalculator.getStiche();
		Result result = stichCalculator.getResult();
		// Idee Rechter: sU
	
		System.out.println();
		System.out.println("Stich Nr. 1");
		System.out.println();
		stiche.add(new Stich(e7, sO, lA, sK, 1));
		result.calcSchlag(stiche);
		//System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new GuaterStichTest(result, stiche).runTest());
		stichCalculator.makeMessage();
		stichCalculator.calculateNewResult();
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getFarbStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getTrumpfStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getLinkerStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getRechterStich());
		assertEquals(CONSTANTS.POSSIBLE, stichCalculator.getGuaterStich());
		System.out.println();
		System.out.println("Stich Nr. 2");
		System.out.println();
		stiche.add(new Stich(e9, sA, sU, e10, 2));
		result.calcSchlag(stiche);
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.POSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		stichCalculator.makeMessage();
// ab hier Änderung weil Result ist nun fix!!
		stichCalculator.calculateNewResult();
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getFarbStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getTrumpfStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getLinkerStich());
		assertEquals(CONSTANTS.SURE, stichCalculator.getRechterStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getGuaterStich());
		System.out.println();
		System.out.println("Stich Nr. 3");
		System.out.println();
		stiche.add(new Stich(e8, lK, lU, l8, 2));
		result.calcSchlag(stiche);
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		stichCalculator.makeMessage();
		stichCalculator.calculateNewResult();
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getFarbStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getTrumpfStich());
		assertEquals(CONSTANTS.SURE, stichCalculator.getLinkerStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getRechterStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getGuaterStich());
		System.out.println();
		System.out.println("Stich Nr. 4");
		System.out.println();
		stiche.add(new Stich(s6, hK, l7, s10, 3));
		result.calcSchlag(stiche);
		System.out.println(result.toString());
		assertEquals(CONSTANTS.IMPOSSIBLE, new FarbStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.SURE, new TrumpfStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new LinkerStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new RechterStichTest(result, stiche).runTest());
		assertEquals(CONSTANTS.IMPOSSIBLE, new GuaterStichTest(result, stiche).runTest());
		stichCalculator.makeMessage();
		stichCalculator.calculateNewResult();
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getFarbStich());
		assertEquals(CONSTANTS.SURE, stichCalculator.getTrumpfStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getLinkerStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getRechterStich());
		assertEquals(CONSTANTS.IMPOSSIBLE, stichCalculator.getGuaterStich());

	}
}


So wie es jetzt aussieht benötigt das Programm nur noch ein grafisches Frontend. Dazu muss das Problem
der Karteneingabe gelöst werden.
Diese Aufgabe könnte eine Klasse CardFactory übernehmen, die Card Objekte gezielt erzeugt.
Die Kontrolle welche Karte und Doppelkarten wären hier gut aufgehoben.

Hier nun der erste Entwurf der CardFactory, der als Singleton entworfen wurde, damit sich beim Erzeugen der 
Karten keine 2 Fabriken in die Quere kommen.

public class CardFactory {
	
	private static boolean factoryCreated = false;
	
	private Card[][] createdCards;
	
	public static CardFactory getCardFactory() {
		if(factoryCreated) return new CardFactory();
		else return null;
	}
	
	private CardFactory() {
		createdCards = new Card[CONSTANTS.ANZAHL_FARBEN][];
		for(Card[] colors : createdCards) colors = new Card[CONSTANTS.ANZAHL_SCHLAEGE];
		createdCards[CONSTANTS.HERZ][CONSTANTS.SECHSER] = new Card(CONSTANTS.HERZ,CONSTANTS.SECHSER);
		createdCards[CONSTANTS.EICHEL][CONSTANTS.SECHSER] = new Card(CONSTANTS.EICHEL,CONSTANTS.SECHSER);
		createdCards[CONSTANTS.LAUB][CONSTANTS.SECHSER] = new Card(CONSTANTS.LAUB,CONSTANTS.SECHSER);
	}
	
	public Card createCard(String cardShortCut) {
		int tokenReadCount = 0;
		char[] tokenArray = cardShortCut.toLowerCase().toCharArray();
		int number = -1;
		int color = -1;
		while(tokenReadCount < tokenArray.length) {
			char token = tokenArray[tokenReadCount];
			switch (token) {
				// setUp Color
				case 'e': color = CONSTANTS.EICHEL; break;
				case 'h': color = CONSTANTS.HERZ; break;
				case 'l': color = CONSTANTS.LAUB; break;
				case 's': color = CONSTANTS.SCHELL; break;
				// setUp Number
				case '0': tokenReadCount++; break;
				case '6': number = CONSTANTS.SECHSER; break;
				case '7': number = CONSTANTS.SIEBNER; break;
				case '8': number = CONSTANTS.ACHTER; break;
				case '9': number = CONSTANTS.NEUNER; break;
				case '1': number = CONSTANTS.ZEHNER; break;
				case 'u': number = CONSTANTS.UNTER; break;
				case 'o': number = CONSTANTS.OBER; break;
				case 'k': number = CONSTANTS.KOENIG; break;
				case 'a': number = CONSTANTS.AS; break;
		
				default: tokenReadCount++; break;
			}
			tokenReadCount++;
		}
		if(createdCards[color][number] == null) {
			return (createdCards[color][number] = new Card(color,number));
		}
		return null;
	}
}

und gleich dannach ans testen, damits wieder ordentlich raucht.

import junit.framework.TestCase;

import watten.CONSTANTS;
import watten.Card;
import watten.CardFactory;

public class Test_CardFactory extends TestCase {

	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	CardFactory cardFactory;

	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);

		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);

		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
		
		cardFactory = CardFactory.getCardFactory();
	}

	public void test_getCard() {
		assertEquals(true, e7.equals(cardFactory.createCard("e7")));
	}
}

Und wirklich krachts gleich am Anfang, sodass der Test: 

	public void test_CardFactory() {
		assertEquals(true, cardFactory != null);
	}
eingefügt wird, der die Wurzel des Übels zeigt!

	public static CardFactory getCardFactory() {
		if(factoryCreated) return new CardFactory();
		else return null;
	}
	
ist natürlich völliger Blödsinn und wir in:

	public static CardFactory getCardFactory() {
		if(factoryAllreadyCreated) return null;
		else return new CardFactory();
	}

umgeschrieben. Dabei wird der Name der Kontrollvariable gleich in eine bessere Variante umbenannt.

Die neue elegante Schleife
for(Card[] colors : createdCards) colors = new Card[CONSTANTS.ANZAHL_SCHLAEGE];
funktioniert leider auch nicht und muss in
for(int i = 0; i < createdCards.length; i++) createdCards[i] = new Card[CONSTANTS.ANZAHL_SCHLAEGE];
geändert werden.

hier dann die um Fehler in der switch Anweisung bereinigte Klasse.
Für 0 und default darf nicht extra weitergezählt werden!

public class CardFactory {
	
	private static boolean factoryAllreadyCreated = false;
	
	private Card[][] createdCards;
	
	public static CardFactory getCardFactory() {
		if(factoryAllreadyCreated) return null;
		else return new CardFactory();
	}
	
	private CardFactory() {
		createdCards = new Card[CONSTANTS.ANZAHL_FARBEN][];
		//for(Card[] colors : createdCards) colors = new Card[CONSTANTS.ANZAHL_SCHLAEGE];
		for(int i = 0; i < createdCards.length; i++) createdCards[i] = new Card[CONSTANTS.ANZAHL_SCHLAEGE];
		createdCards[CONSTANTS.HERZ][CONSTANTS.SECHSER] = new Card(CONSTANTS.HERZ,CONSTANTS.SECHSER);
		createdCards[CONSTANTS.EICHEL][CONSTANTS.SECHSER] = new Card(CONSTANTS.EICHEL,CONSTANTS.SECHSER);
		createdCards[CONSTANTS.LAUB][CONSTANTS.SECHSER] = new Card(CONSTANTS.LAUB,CONSTANTS.SECHSER);
	}
	
	public Card createCard(String cardShortCut) {
		int tokenReadCount = 0;
		char[] tokenArray = cardShortCut.toLowerCase().toCharArray();
		int number = CONSTANTS.SECHSER;
		int color = CONSTANTS.EICHEL;
		while(tokenReadCount < tokenArray.length) {
			char token = tokenArray[tokenReadCount];
			switch (token) {
				// setUp Color
				case 'e': color = CONSTANTS.EICHEL; break;
				case 'h': color = CONSTANTS.HERZ; break;
				case 'l': color = CONSTANTS.LAUB; break;
				case 's': color = CONSTANTS.SCHELL; break;
				// setUp Number

				case '6': number = CONSTANTS.SECHSER; break;
				case '7': number = CONSTANTS.SIEBNER; break;
				case '8': number = CONSTANTS.ACHTER; break;
				case '9': number = CONSTANTS.NEUNER; break;
				case '1': number = CONSTANTS.ZEHNER; break;
				case 'u': number = CONSTANTS.UNTER; break;
				case 'o': number = CONSTANTS.OBER; break;
				case 'k': number = CONSTANTS.KOENIG; break;
				case 'a': number = CONSTANTS.AS; break;
		
				default: break;
			}
			tokenReadCount++;
		}
		if(createdCards[color][number] == null) {
			return (createdCards[color][number] = new Card(color,number));
		}
		return null;
	}
}

mit der Testklasse:

public class Test_CardFactory extends TestCase {

	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	CardFactory cardFactory;

	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);

		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);

		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
		
		cardFactory = CardFactory.getCardFactory();
	}

	public void test_CardFactory() {
		assertEquals(true, cardFactory != null);
	}
	public void test_getCard() {
		assertEquals(true, e7.equals(cardFactory.createCard("e7")));
		assertEquals(true, cardFactory.createCard("e7") == null);
		
		assertEquals(true, e8.equals(cardFactory.createCard("8e")));
		assertEquals(true, cardFactory.createCard("e8") == null);
		
		assertEquals(true, e10.equals(cardFactory.createCard("e10")));
		assertEquals(true, cardFactory.createCard("10e") == null);
		
		assertEquals(true, h10.equals(cardFactory.createCard("10h")));
		assertEquals(true, cardFactory.createCard("10e") == null);
		
		assertEquals(true, lK.equals(cardFactory.createCard("KL")));
		assertEquals(true, cardFactory.createCard("LK") == null);
		
		assertEquals(true, sA.equals(cardFactory.createCard("SA")));
		assertEquals(true, cardFactory.createCard("aS") == null);
	}
}

Jetzt noch eine Klasse, die einen Stich erzeugt:

import java.io.IOException;
import java.io.StreamTokenizer;
import java.io.StringReader;

public class StichFactory {
	
	private static boolean factoryAllreadyCreated = false;
	
	public static StichFactory getStichFactory() {
		if(factoryAllreadyCreated) return null;
		else return new StichFactory();
	}
	
	private CardFactory cardFactory;

	public StichFactory() {
		cardFactory = CardFactory.getCardFactory();
	}
	
	public Stich createStich(String inputString) {
		int createdCardNumber = 0;
		Card[] cardArray = new Card[CONSTANTS.CARDS_IN_STICH];
		int winnerNumber = -1;
		StreamTokenizer streamTokenizer = new StreamTokenizer(new StringReader(inputString));
		streamTokenizer.quoteChar(CONSTANTS.QUOTE_CHAR);
		//streamTokenizer.ordinaryChars('0','9');
		try {
			while(createdCardNumber < cardArray.length) {
				streamTokenizer.nextToken();
				System.out.println("Token Nummer: " + createdCardNumber + " = " + streamTokenizer.sval);
				cardArray[createdCardNumber] = cardFactory.createCard(streamTokenizer.sval);
				if(cardArray[createdCardNumber] == null) return null;
				createdCardNumber++;
			}
			streamTokenizer.resetSyntax();
			streamTokenizer.parseNumbers();
			streamTokenizer.nextToken();
			winnerNumber = new Double(streamTokenizer.nval).intValue();
			if(winnerNumber < 0 || winnerNumber > 3) return null;
		} catch (IOException e) {
			System.out.println("Could not create new Stich!");
		}
		return  new Stich(cardArray[0],cardArray[1],cardArray[2],cardArray[3], winnerNumber);
	}
}

und die Tests dazu:

import junit.framework.TestCase;

import watten.CONSTANTS;
import watten.Card;
import watten.StichFactory;

public class Test_StichFactory extends TestCase {

	Card hA, hK, hO, hU, h10, h9, h8, h7;
	Card sA, sK, sO, sU, s10, s9, s8, s7, s6;
	Card eA, eK, eO, eU, e10, e9, e8, e7;
	Card lA, lK, lO, lU, l10, l9, l8, l7;
	StichFactory stichFactory;

	public void setUp() {
		hA = new Card(CONSTANTS.HERZ, CONSTANTS.AS);
		hK = new Card(CONSTANTS.HERZ, CONSTANTS.KOENIG);
		hO = new Card(CONSTANTS.HERZ, CONSTANTS.OBER);
		hU = new Card(CONSTANTS.HERZ, CONSTANTS.UNTER);
		h10 = new Card(CONSTANTS.HERZ, CONSTANTS.ZEHNER);
		h9 = new Card(CONSTANTS.HERZ, CONSTANTS.NEUNER);
		h8 = new Card(CONSTANTS.HERZ, CONSTANTS.ACHTER);
		h7 = new Card(CONSTANTS.HERZ, CONSTANTS.SIEBNER);
		
		sA = new Card(CONSTANTS.SCHELL, CONSTANTS.AS);
		sK = new Card(CONSTANTS.SCHELL, CONSTANTS.KOENIG);
		sO = new Card(CONSTANTS.SCHELL, CONSTANTS.OBER);
		sU = new Card(CONSTANTS.SCHELL, CONSTANTS.UNTER);
		s10 = new Card(CONSTANTS.SCHELL, CONSTANTS.ZEHNER);
		s9 = new Card(CONSTANTS.SCHELL, CONSTANTS.NEUNER);
		s8 = new Card(CONSTANTS.SCHELL, CONSTANTS.ACHTER);
		s7 = new Card(CONSTANTS.SCHELL, CONSTANTS.SIEBNER);
		s6 = new Card(CONSTANTS.SCHELL, CONSTANTS.SECHSER);

		eA = new Card(CONSTANTS.EICHEL, CONSTANTS.AS);
		eK = new Card(CONSTANTS.EICHEL, CONSTANTS.KOENIG);
		eO = new Card(CONSTANTS.EICHEL, CONSTANTS.OBER);
		eU = new Card(CONSTANTS.EICHEL, CONSTANTS.UNTER);
		e10 = new Card(CONSTANTS.EICHEL, CONSTANTS.ZEHNER);
		e9 = new Card(CONSTANTS.EICHEL, CONSTANTS.NEUNER);
		e8 = new Card(CONSTANTS.EICHEL, CONSTANTS.ACHTER);
		e7 = new Card(CONSTANTS.EICHEL, CONSTANTS.SIEBNER);

		lA = new Card(CONSTANTS.LAUB, CONSTANTS.AS);
		lK = new Card(CONSTANTS.LAUB, CONSTANTS.KOENIG);
		lO = new Card(CONSTANTS.LAUB, CONSTANTS.OBER);
		lU = new Card(CONSTANTS.LAUB, CONSTANTS.UNTER);
		l10 = new Card(CONSTANTS.LAUB, CONSTANTS.ZEHNER);
		l9 = new Card(CONSTANTS.LAUB, CONSTANTS.NEUNER);
		l8 = new Card(CONSTANTS.LAUB, CONSTANTS.ACHTER);
		l7 = new Card(CONSTANTS.LAUB, CONSTANTS.SIEBNER);
		
		stichFactory = StichFactory.getStichFactory();
	}

	public void test_StichFactory() {
		assertEquals(true, stichFactory != null);
	}
	public void test_createStich() {
		assertEquals(true,hA.equals(stichFactory.createStich("hk,ha,l7,s9,1").getWinner()));
		assertEquals(true,stichFactory.createStich("hk,ha,l7,s9,1") == null);
		assertEquals(true,eO.equals(stichFactory.createStich("9h,eK,oh,Oe,3").getWinner()));
	}
}

doch leider schafft der StreamTokenizer es nicht 9l oder 9s als String auszugeben.
Daher wird wieder umgebaut und dann klappts!

Jetzt fehlt "nur" noch die Klasse die alles elegant zusammenfasst, einen VirtualPlayer sozusagen.
Dieser soll die Verwaltung folgender Dinge übernehmen:
Stiche
Result

Das reduziert die Klasse StichCalculator auf eine reine Berechnungsklasse und ein Teil ihre Daten wird nach 
VirtualPlayer wandern.
Beim Betrachten der Klasse StichCalculator fällt auf, dass die "logischen Variable" eigentlich in einem PossibilityArray 
abgespeichert werden könnten. Die Ausschlussregeln liessen sich so einfach regeln.
Zusätzlich wäre eine Methode getLastWinner() in stiche recht angenehm.
Fein wäre auch in result mit setLinker(Card karte) einfach einen Linken setzten zu können!

Neuer Tag und wir wollen ihn mit Aufräumen beginnen:
Die Singeltons aus den Factories sollen entfernt werden und StichCalculator soll seine Daten über den Konstruktor 
bekommen.


import java.util.ArrayList;
import java.util.Observable;
import java.util.Observer;


public class StichCalculator implements Observer {
	
	private ArrayList<Stich> stiche;
	private Result result;
	
	private int farbStich;
	private int trumpfStich;
	private int linkerStich;
	private int rechterStich;
	private int guaterStich;
	private boolean resultChanged;
	
	public StichCalculator(ArrayList<Stich> stiche, Result result) {
		this.stiche = stiche;
		this.result = result;
		this.result.addObserverToSchlagAndTrumpf(this);
	}
	
	public void update(Observable observable, Object arg) {
		resultChanged = true;
	}
	
	// Zum Testen
	public int getFarbStich() { return farbStich; }
	//public void setFarbStich(int farbStich) { this.farbStich = farbStich; }
	
	public int getTrumpfStich() { return trumpfStich; }
	//public void setTrumpfStich(int trumpfStich) { this.trumpfStich = trumpfStich; }
	
	public int getLinkerStich() { return linkerStich;  }
	//public void setLinkerStich(int linkerStich) { this.linkerStich = linkerStich; }
	
	public int getRechterStich() { return rechterStich; }
	//public void setRechterStich(int rechterStich) { this.rechterStich = rechterStich;	}
	
	public int getGuaterStich() { return guaterStich; }
	//public void setGuaterStich(int guaterStich) { this.guaterStich = guaterStich; }
		
	public String getMessage() {
		calculateNewResult();
		StringBuffer message = new StringBuffer();
		message.append(CONSTANTS.messageFarbStich);
		message.append(translate(farbStich));
		message.append(CONSTANTS.messageTrumpfStich);
		message.append(translate(trumpfStich));
		message.append(CONSTANTS.messageLinkerStich);
		message.append(translate(linkerStich));
		message.append(CONSTANTS.messageRechterStich);
		message.append(translate(rechterStich));
		if(result.isMitGuatem()) {
			message.append(CONSTANTS.messageGuaterStich);
			message.append(translate(guaterStich));
		}
		return message.toString();
	}
	
	private String translate(int posibility) {
		if(posibility == CONSTANTS.IMPOSSIBLE) return CONSTANTS.messageIMPOSSIBLE; 
		if(posibility == CONSTANTS.POSSIBLE) return CONSTANTS.messagePOSSIBLE; 
		else return CONSTANTS.messageSURE;
	}
	

	private void calculateNewResult() {
		result.calcSchlag(stiche);
		do {
			resultChanged = false;
			runTest();
			runRules();
			runExcept4Rules();
		} while(resultChanged);
		
	}

	private void runTest() {
		farbStich = new FarbStichTest(result,stiche).runTest();
		trumpfStich = new TrumpfStichTest(result,stiche).runTest();
		linkerStich = new LinkerStichTest(result,stiche).runTest();
		rechterStich = new RechterStichTest(result,stiche).runTest();
		guaterStich = new GuaterStichTest(result,stiche).runTest();
	}
	
	private void runRules() {
		if(isTrumpfImpossible()) lastWinnerIsNoTrumpf();
		if(isSchlagOrGuaterImpossible()) lastWinnerIsNoSchlag();		
	}
	
	private boolean isTrumpfImpossible() {
		return trumpfStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE;
	}
	
	private boolean isSchlagOrGuaterImpossible() {
		return linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE;
	}
	
	private void lastWinnerIsNoTrumpf() {
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.IMPOSSIBLE);
	}
	
	private void lastWinnerIsNoSchlag() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.IMPOSSIBLE);
	}
	
	private void runExcept4Rules() {
		if(justGuaterStichPossible()) lastWinnerIsGuater();
		if(justRechterStichPossible()) lastWinnerIsRechter();
		if(justLinkerStichPossible()) lastWinnerIsLinker();
		if(justTrumpfStichPossible()) lastWinnerIsTrumpf();
		if(justFarbStichPossible()) lastWinnerIsFarbe();	
	}
	// logical Tests
	private boolean justGuaterStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && trumpfStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE);
	}
	
	private boolean justRechterStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && trumpfStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE);
	}
	
	private boolean justLinkerStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && trumpfStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE);
	}
	
	private boolean justTrumpfStichPossible() {
		return (farbStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE );
	}
	
	private boolean justFarbStichPossible() {
		return (trumpfStich == CONSTANTS.IMPOSSIBLE && linkerStich == CONSTANTS.IMPOSSIBLE && rechterStich == CONSTANTS.IMPOSSIBLE && guaterStich == CONSTANTS.IMPOSSIBLE );
	}
	
	// set Values in Result
	private void lastWinnerIsGuater() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().getPreviousNumberCard().number,CONSTANTS.SURE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.SURE);
	}
	
	private void lastWinnerIsRechter() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.SURE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.SURE);
	}
	
	private void lastWinnerIsLinker() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.SURE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.IMPOSSIBLE);
	}
	
	private void lastWinnerIsTrumpf() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.IMPOSSIBLE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.SURE);
	}
	
	private void lastWinnerIsFarbe() {
		result.setNumberAt(stiche.get(stiche.size()-1).getWinner().number,CONSTANTS.IMPOSSIBLE);
		result.setColorAt(stiche.get(stiche.size()-1).getWinner().color,CONSTANTS.IMPOSSIBLE);
	}
}

StichCalculator hat sich wie oben verändert, bietet aber noch einiges an Verbesserungspotential. z.B.: 
Logikvariablen als Array.

Für das grafische Frontend wird das Frontend von Findword verwendet:

Aus 

import javax.swing.*;
import java.awt.*;

public class FindWordApplet extends JApplet {

	private static final long serialVersionUID = 3546365024081097528L;

	public static void main(String args[]) {
		SwingUtilities.invokeLater(new Runnable() {
				public void run() { createAndShowGUI(); }
		});
	};
	
	private static void createAndShowGUI() {
		//JFrame.setDefaultLookAndFeelDecorated(true);
		JFrame aFrame = new JFrame("find Word");
		aFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		aFrame.setContentPane(new CharGridPanel());
		aFrame.setSize(new Dimension(500,500));
		aFrame.setLocation(130,30);
		aFrame.setVisible(true);
	}

	public void init() {
		setContentPane(new CharGridPanel());
	}
}

wird 

mport javax.swing.*;
import java.awt.*;

public class FindRechterApplet extends JApplet {

	private static final long serialVersionUID = 3546365024081097528L;

	public static void main(String args[]) {
		SwingUtilities.invokeLater(new Runnable() {
				public void run() { createAndShowGUI(); }
		});
	};
	
	private static void createAndShowGUI() {
		//JFrame.setDefaultLookAndFeelDecorated(true);
		JFrame aFrame = new JFrame("Find Schlag & Trumpf");
		aFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		aFrame.setContentPane(new WattenPanel());
		aFrame.setSize(new Dimension(500,500));
		aFrame.setLocation(130,30);
		aFrame.setVisible(true);
	}

	public void init() {
		setContentPane(new WattenPanel());
	}
}
 
und aus 

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class CharGridPanel extends JPanel {

	private static final long serialVersionUID = 3257286928792762417L;
	
	private JTextField theWord, numberOfSolutions;
	private JTextArea inputTextArea, outputTextArea;
	private JCheckBox useCharOnceCheckBox;
	private CharGrid theCharGrid;
	private FindWordAlgorithmus theFindWordAlgorithmus;
	
	public CharGridPanel() {
		this.initComponents();
		this.theCharGrid = new CharGrid(inputTextArea);
		this.theFindWordAlgorithmus = new FindWordAlgorithmus(theCharGrid);
		this.theFindWordAlgorithmus.setGUI(numberOfSolutions,outputTextArea);
		this.useCharOnceCheckBox.setSelected(theFindWordAlgorithmus.isUseCharOnce());
	}
	
	private void initComponents() {
		this.setLayout(new BorderLayout());
		this.setBorder(BorderFactory.createEtchedBorder());
		this.add(createTopLabel(), BorderLayout.NORTH);
		this.add(createCenter(),BorderLayout.CENTER);
	}

	private JLabel createTopLabel() {
		JLabel jHeaderLabel = new JLabel(">> Word Finder <<");
		jHeaderLabel.setHorizontalAlignment(SwingConstants.CENTER);
		jHeaderLabel.setFont(new java.awt.Font("Default", 1, 24));
		return jHeaderLabel;
	}

	private JPanel createCenter() {
		JPanel inputOutputPAnel = new JPanel(new GridLayout(2,1));
		inputOutputPAnel.add(createInputPanel());
		inputOutputPAnel.add(createOutputPanel());
		return inputOutputPAnel;
	}

	private JPanel createInputPanel() {
		JPanel inputPanel = new JPanel(new BorderLayout());
		inputPanel.add(createInputToTestWordPanel(),BorderLayout.NORTH);
		inputPanel.add(createInputToTestSentencePanel(),BorderLayout.CENTER);
		return inputPanel;
	}
	
	private JPanel createInputToTestWordPanel() {
		JPanel inputWordPanel = new JPanel(new GridLayout(2,2));
		// add to Component (1/1);
		JLabel theWordLabel = new JLabel("     Zu suchendes Wort:");
		inputWordPanel.add(theWordLabel);
		// add to Component (1/2)
		theWord = new JTextField();
		inputWordPanel.add(theWord);
		// add to Component (2/1)
		inputWordPanel.add(new JLabel("     Jede Position maximal 1 mal:"));
		// add to Component (2/2)
		useCharOnceCheckBox = new JCheckBox();
		useCharOnceCheckBox.addMouseListener(new MouseAdapter() {
			public void mousePressed(MouseEvent e) {
				theFindWordAlgorithmus.setUseCharOnce(!theFindWordAlgorithmus.isUseCharOnce()); }
		});
		inputWordPanel.add(useCharOnceCheckBox);
		return inputWordPanel;
	}

	private JScrollPane createInputToTestSentencePanel() {
		inputTextArea = new JTextArea(10,10);
		inputTextArea.setFont(new Font("Monospaced",Font.PLAIN,12));
		JScrollPane aJScrollPane = new JScrollPane(inputTextArea);
		return aJScrollPane;
	}

	private JPanel createOutputPanel() {
		JPanel outputPanel = new JPanel(new BorderLayout());
		outputPanel.add(createStartButtonAndNumberOfSolutionsPanel(),BorderLayout.NORTH);
		outputTextArea = new JTextArea(10,10);
		JScrollPane aJScrollPane = new JScrollPane(outputTextArea);
		outputPanel.add(aJScrollPane,BorderLayout.CENTER);
		return outputPanel;
	}

	private JPanel createStartButtonAndNumberOfSolutionsPanel() {
		JPanel outputButtonAndNumberOfSolutions = new JPanel(new GridLayout(2,1));
		// add Component to (1/1)
		JButton findWord = new JButton("finde Wort!");
		findWord.addMouseListener(new MouseAdapter() {
			public void mousePressed(MouseEvent e) { theFindWordAlgorithmus.findSolutions(theWord.getText()); }
		});
		outputButtonAndNumberOfSolutions.add(findWord);
		// add Component to (2/1)
		JPanel solutionsPanel = new JPanel(new GridLayout(1,2));
		// add Component to (1/1)
		JLabel theSolutionLabel = new JLabel("Anzahl der gefundenen Lösungen:");
		theSolutionLabel.setHorizontalAlignment(SwingConstants.CENTER);
		solutionsPanel.add(theSolutionLabel);
		// add Component to (1/2)
		numberOfSolutions = new JTextField();
		solutionsPanel.add(numberOfSolutions);
		outputButtonAndNumberOfSolutions.add(solutionsPanel);
		return outputButtonAndNumberOfSolutions;
	}
}

wird zu 

import java.awt.*;
import java.awt.event.*;
import java.util.StringTokenizer;

import javax.swing.*;

import watten.CONSTANTS;
import watten.VirtualPlayer;

public class WattenPanel extends JPanel {

	private static final long serialVersionUID = 3257286928792762417L;
	
	private boolean mitGuatem;
	private String lastCorrectInput, lastCorrectOutput;
	VirtualPlayer virtualPlayer;
	
	private JTextArea inputTextArea, outputTextArea;
	private JCheckBox mitGuatemCheckBox;
	
	
	public WattenPanel() {
		this.initComponents();
		this.newGame(true);
		mitGuatemCheckBox.setSelected(mitGuatem);
	}
	
	private void newGame(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		lastCorrectInput = "";
		this.lastCorrectOutput = "";
		this.inputTextArea.setText("");
		this.outputTextArea.setText("");
		virtualPlayer = new VirtualPlayer(mitGuatem);
	}
	
	private void initComponents() {
		this.setLayout(new BorderLayout());
		this.setBorder(BorderFactory.createEtchedBorder());
		this.add(createTopLabel(), BorderLayout.NORTH);
		this.add(createCenter(),BorderLayout.CENTER);
	}

	private JComponent createTopLabel() {
		JLabel jHeaderLabel = new JLabel(CONSTANTS.labelProgramHeader);
		jHeaderLabel.setHorizontalAlignment(SwingConstants.CENTER);
		jHeaderLabel.setFont(new java.awt.Font("Default", 1, 24));
		return jHeaderLabel;
	}

	private JComponent createCenter() {
		JPanel inputOutputPanel = new JPanel(new GridLayout(2,1));
		inputOutputPanel.add(createInputPanel());
		inputOutputPanel.add(createOutputPanel());
		return inputOutputPanel;
	}

	private JComponent createInputPanel() {
		JPanel inputPanel = new JPanel(new BorderLayout());
		inputPanel.add(createControlPanel(),BorderLayout.NORTH);
		inputPanel.add(createSticheInputPanel(),BorderLayout.CENTER);
		//inputPanel.add(createResultPanel(),BorderLayout.SOUTH);
		return inputPanel;
	}
	
	private JComponent createControlPanel() {
		JPanel controlPanel = new JPanel(); //new GridLayout(1,2));
		// add to Component (1/1);
		controlPanel.add(new JLabel(CONSTANTS.labelGameWithGuatem));
		// add to Component (1/2)
		mitGuatemCheckBox = new JCheckBox();
		mitGuatemCheckBox.addMouseListener(new MouseAdapter() {
			public void mousePressed(MouseEvent e) { 
				if(lastCorrectInput.equals("")) newGame(!mitGuatem);
				else {
					outputTextArea.append(CONSTANTS.ERROR_Game_Status_Unchangeable);
					mitGuatemCheckBox.setSelected(!mitGuatemCheckBox.isSelected());
				}
			}
		});
		controlPanel.add(mitGuatemCheckBox);
		JButton newGame = new JButton(CONSTANTS.labelNewGame);
		newGame.addMouseListener(new MouseAdapter() {
			public void mousePressed(MouseEvent e) { newGame(mitGuatem); }
		});
		controlPanel.add(newGame);
		return controlPanel;
	}

	private JComponent createSticheInputPanel() {
		inputTextArea = new JTextArea(4,14);
		inputTextArea.setFont(new Font("Monospaced",Font.PLAIN,12));
		inputTextArea.addKeyListener(new KeyAdapter() {
			public void keyReleased(KeyEvent e) {
				if(e.getKeyCode() == KeyEvent.VK_ENTER)
					handleNewStich();
			}
		});
		JScrollPane aJScrollPane = new JScrollPane(inputTextArea);
		return aJScrollPane;
	}
	
	private void handleNewStich() {
		StringTokenizer lineCreator = new StringTokenizer(inputTextArea.getText(),"\n");
		if(lineCreator.countTokens() == 0) return;
		while(lineCreator.countTokens() > 1) lineCreator.nextToken();
		if(virtualPlayer.isAddStichPossible(lineCreator.nextToken())) {
			lastCorrectInput = inputTextArea.getText();
			outputTextArea.setText(lastCorrectOutput);
			outputTextArea.append(virtualPlayer.getMessage());
			//lastCorrectInput = inputTextArea.getText();
			lastCorrectOutput = outputTextArea.getText();
		} else outputTextArea.append(virtualPlayer.getErrorMessage());
	}
	
	private JComponent createOutputPanel() {
		JPanel outputPanel = new JPanel(new BorderLayout());
		//outputPanel.add(createStartButtonAndNumberOfSolutionsPanel(),BorderLayout.NORTH);
		outputTextArea = new JTextArea(10,10);
		JScrollPane aJScrollPane = new JScrollPane(outputTextArea);
		outputPanel.add(aJScrollPane,BorderLayout.CENTER);
		return outputPanel;
	}
	
	private JPanel createResultPanel() {
	}
}

Bei den Test ist dann noch ein Fehler aufgefallen:

Wird zum Beispiel h7,h8,h9,h19,3 eingegeben, dann taucht die Fehlermeldung zwar richtig auf, aber 
h7,h8 und h9 sind für eine weitere Eingabe gesperrt und der Stich h7,h8,h9,h10,3 kann nicht mehr richtig 
eingegeben werden.
Karten aus unfertigen Sichen müssen daher wieder freigegeben werden!

In CardFactory wird deshalb eine Methode resetCard(Card card) einzubauen sein und in StichFactory werden
alle Karten aus nichtfertigen Stichen "resetet" werden müssen.

	public void resetCard(Card card) {
		createdCards[card.color][card.number] = null;
	}

mit den Tests:

	public void test_resetCard() {
		StringBuffer errorMessage = new StringBuffer("");
		CardFactory cardFactory =  new CardFactory(errorMessage);
		assertEquals(true, s9.equals(cardFactory.createCard("9s")));
		assertEquals(true, cardFactory.createCard("9s") == null);
		cardFactory.resetCard(s9);
		assertEquals(true, s9.equals(cardFactory.createCard("9s")));
	}

Die Änderung in StichFactory

import java.util.StringTokenizer;

public class StichFactory {
	
	private CardFactory cardFactory;
	private StringBuffer errorMessage;

	public StichFactory(StringBuffer errorMessage) {
		this.errorMessage = errorMessage;
		this.cardFactory = new CardFactory(errorMessage);
	}
	
	public Stich createStich(String inputString) {
		int createdCardNumber = 0;
		Card[] cardArray = new Card[CONSTANTS.CARDS_IN_STICH];
		int winnerNumber = -1;
		StringTokenizer stringTokenizer = new StringTokenizer(inputString,CONSTANTS.QUOTE_STRING);
			while(createdCardNumber < cardArray.length) {
				cardArray[createdCardNumber] = cardFactory.createCard(stringTokenizer.nextToken());
				if(cardArray[createdCardNumber] == null) {
					errorMessage.append(CONSTANTS.ERROR_Could_Not_Create_Stich);
					for(int i = 0; i < createdCardNumber; i++) cardFactory.resetCard(cardArray[i]);
					return null;
				}
				createdCardNumber++;
			}
			winnerNumber = new Integer(stringTokenizer.nextToken()).intValue();
			if(winnerNumber < 0 || winnerNumber > 3) {
				for(int i = 0; i < cardArray.length; i++) cardFactory.resetCard(cardArray[i]);
				errorMessage.append(CONSTANTS.ERROR_Wrong_WinnerNumber);
				errorMessage.append(CONSTANTS.ERROR_Could_Not_Create_Stich);
				return null;
			}
		return  new Stich(cardArray[0],cardArray[1],cardArray[2],cardArray[3], winnerNumber);
	}
}


und die Tests dazu:

	public void test_reset_Cards_In_Stich() {
		StringBuffer errorMessage = new StringBuffer("");
		StichFactory stichFactory = new StichFactory(errorMessage);
		assertEquals(true,hA.equals(stichFactory.createStich("hk,ha,l7,s9,1").getWinner()));
		assertEquals(true,stichFactory.createStich("ek,ea,s7,s19,1") == null);
		
		assertEquals(true,eA.equals(stichFactory.createStich("ek,ea,s7,s10,1").getWinner()));
	}
	
Allerdings haben sich noch weitere Fehler eingeschlichen:
in CardFactory wurde die Karte g8 erzeugt, da g einfach übersprungen und 8 erzeugt werden konnte.
Da die Standardkarte e6 war, wurde dies in e8 geändert und fertig.

daher hier die neue version:

public class CardFactory {
	
	private Card[][] createdCards;
	private StringBuffer errorMessage;
	
	public CardFactory(StringBuffer errorMessage) {
		this.errorMessage = errorMessage;
		createdCards = new Card[CONSTANTS.ANZAHL_FARBEN][];
		//for(Card[] colors : createdCards) colors = new Card[CONSTANTS.ANZAHL_SCHLAEGE];
		for(int i = 0; i < createdCards.length; i++) createdCards[i] = new Card[CONSTANTS.ANZAHL_SCHLAEGE];
		createdCards[CONSTANTS.HERZ][CONSTANTS.SECHSER] = new Card(CONSTANTS.HERZ,CONSTANTS.SECHSER);
		createdCards[CONSTANTS.EICHEL][CONSTANTS.SECHSER] = new Card(CONSTANTS.EICHEL,CONSTANTS.SECHSER);
		createdCards[CONSTANTS.LAUB][CONSTANTS.SECHSER] = new Card(CONSTANTS.LAUB,CONSTANTS.SECHSER);
	}
	
	public Card createCard(String cardShortCut) {
		if(cardShortCut == null)  return null;
		int tokenReadCount = 0;
		char[] tokenArray = cardShortCut.toLowerCase().toCharArray();
		int number = CONSTANTS.IMPOSSIBLE;
		int color = CONSTANTS.IMPOSSIBLE;
		while(tokenReadCount < tokenArray.length) {
			char token = tokenArray[tokenReadCount];
			switch (token) {
				// setUp Color
				case 'e': color = CONSTANTS.EICHEL; break;
				case 'h': color = CONSTANTS.HERZ; break;
				case 'l': color = CONSTANTS.LAUB; break;
				case 's': color = CONSTANTS.SCHELL; break;
				// setUp Number

				case '6': number = CONSTANTS.SECHSER; break;
				case '7': number = CONSTANTS.SIEBNER; break;
				case '8': number = CONSTANTS.ACHTER; break;
				case '9': number = CONSTANTS.NEUNER; break;
				case '1': number = CONSTANTS.ZEHNER; break;
				case 'u': number = CONSTANTS.UNTER; break;
				case 'o': number = CONSTANTS.OBER; break;
				case 'k': number = CONSTANTS.KOENIG; break;
				case 'a': number = CONSTANTS.AS; break;
		
				default: break;
			}
			tokenReadCount++;
		}
		if(isCardCreatable(color, number)) 
			return (createdCards[color][number] = new Card(color,number));
		else {
			errorMessage.append(CONSTANTS.ERROR_Could_Not_Create_Card1);
			errorMessage.append(cardShortCut);
			errorMessage.append(CONSTANTS.ERROR_Could_Not_Create_Card2);
			return null;
		}
	}
	
	private boolean isCardCreatable(int color, int number) {
		return color != CONSTANTS.IMPOSSIBLE && 
		       number != CONSTANTS.IMPOSSIBLE &&
		       createdCards[color][number] == null;
	}
	
	public void resetCard(Card card) {
		createdCards[card.color][card.number] = null;
	}
}

In StichFactory musste noch eine NumberFormatException abgefangen werden siehe unten:


	public Stich createStich(String inputString) {
		int createdCardNumber = 0;
		Card[] cardArray = new Card[CONSTANTS.CARDS_IN_STICH];
		int winnerNumber = -1;
		StringTokenizer stringTokenizer = new StringTokenizer(inputString,CONSTANTS.QUOTE_STRING);
			while(createdCardNumber < cardArray.length) {
				cardArray[createdCardNumber] = cardFactory.createCard(stringTokenizer.nextToken());
				if(cardArray[createdCardNumber] == null) {
					errorMessage.append(CONSTANTS.ERROR_Could_Not_Create_Stich);
					for(int i = 0; i < createdCardNumber; i++) cardFactory.resetCard(cardArray[i]);
					return null;
				}
				createdCardNumber++;
			}
			try {
				winnerNumber = new Integer(stringTokenizer.nextToken()).intValue();
			} catch(NumberFormatException e) { winnerNumber = CONSTANTS.IMPOSSIBLE; }
			if(winnerNumber < 0 || winnerNumber > 3) {
				for(int i = 0; i < cardArray.length; i++) cardFactory.resetCard(cardArray[i]);
				errorMessage.append(CONSTANTS.ERROR_Wrong_WinnerNumber);
				errorMessage.append(CONSTANTS.ERROR_Could_Not_Create_Stich);
				return null;
			}
		return  new Stich(cardArray[0],cardArray[1],cardArray[2],cardArray[3], winnerNumber);
	}
	
Soweit scheint nun alles zu funktioniern, aber die letzte Karte im Stich wird, wenn ihr Schlag unmöglich ist 
nicht grafisch aktualisiert. Die Observer werden wahrscheinlich vor dem eigentlichen setzten informiert:

public void setValueAt(int position, int value) {
		handleObserver(position, value);
		if(value == CONSTANTS.SURE) {
			for(int pos = 0; pos < array.length; pos++) array[pos] = CONSTANTS.IMPOSSIBLE;
			array[position] = value;
		} else {
			array[position] = value;
			correctIfOnePossibleLeft();
		}
	}
	
	private void handleObserver(int position, int value) {
		if(value != array[position]) {
			setChanged();
			notifyObservers(array.clone());
		}
	}

	
Dieser Fehler muss noch behoben werden!

import java.util.Observable;

public class PossibilityArray extends Observable implements Cloneable {
	
	private int[] array;
	
	public PossibilityArray(int size) {
		this.array = new int[size];
	}
	
	public PossibilityArray clone() throws CloneNotSupportedException {
		PossibilityArray tempPossibilityArray = new PossibilityArray(array.length);
		for(int i = 0; i < array.length; i++) tempPossibilityArray.setValueAt(i,array[i]);
		return tempPossibilityArray;
	}
	
	public String toString() {
		StringBuffer tempString = new StringBuffer();
		tempString.append(super.toString());
		tempString.append("\n Values: ");
		for(int i = 0; i < array.length; i++) {
			tempString.append(" v[" + i + "]=" + array[i]);
		}
		return tempString.toString();
	}
	
	public int getLength() { return array.length; }
	
	public void setValueAt(int position, int value) {
		if(value != array[position]) setChanged();
		if(value == CONSTANTS.SURE) {
			for(int pos = 0; pos < array.length; pos++) array[pos] = CONSTANTS.IMPOSSIBLE;
			array[position] = value;
		} else {
			array[position] = value;
			correctIfOnePossibleLeft();
		}
		notifyObservers(array.clone());
	}
	
	public int get(int position) {
		return array[position];
	}
	
	private void correctIfOnePossibleLeft() {
		int coutZeros = 0;
		int rememberZeroPosition = 0;
		for(int position = 0; position < array.length; position++)
			if(array[position] == CONSTANTS.POSSIBLE) {
				coutZeros++;
				rememberZeroPosition = position;
			}
		if(coutZeros == 1) array[rememberZeroPosition] = CONSTANTS.SURE;
	}

	public int findFirstSure() {
		int position = array.length - 1;
		while(position >= 0 && array[position] != CONSTANTS.SURE) 
			position--;
		return position;
	}
}


Beim weiteren Testen ist noch was Interessantes aufgefallen.
Bei einem Stich der Form e10,ha,s6,ek,3 ist klar, dass das wegen dem veli kein Farbstich sein kann!
Das wird auch wirklich erkannt.
Wenn in der Klasse 	FarbStichTest die Methode 
public int setTestSpezials() {  setAllColorsInLastStichToImpossible(); }
weggelassen wird, funktionieren weiterhin alle! Tests. Auch Test_StichCalculator. Woh!

Was leider noch nicht funktioniert ist das Zurücksetzten des Schlages und des Trumpfes beim Starten 
eines neuen Spieles.
Hier werden Updates erst bei der nächsten Veränderung durchgeführt.

Eine Methode resetLabelColors() in PossibilityArrayPanel soll dem abhelfen:

public void resetLabelColors() {
		for(int labels = 0; labels < labelArray.length;labels++) {
			aPanel.getComponent(labels + 1).setForeground(Color.BLACK);
			aPanel.repaint();
		}
	}

	private void newGame(boolean mitGuatem) {
		this.mitGuatem = mitGuatem;
		lastCorrectInput = "";
		this.lastCorrectOutput = "";
		this.inputTextArea.setText("");
		this.outputTextArea.setText("");
		virtualPlayer = new VirtualPlayer(mitGuatem);
		virtualPlayer.getResult().getTrumpfPossibilityArray().addObserver(trumpfPanel);
		virtualPlayer.getResult().getSchlagPossibilityArray().addObserver(schlagPanel);
		trumpfPanel.resetLabelColors();
		schlagPanel.resetLabelColors();
	}
	
In SichFactory wurde 

try {
				winnerNumber = new Integer(stringTokenizer.nextToken()).intValue() - 1;
			} catch(NumberFormatException e) { winnerNumber = CONSTANTS.IMPOSSIBLE; }
			
noch -1 hinzugefügt, damit die Gewinnnummern 1,2,3 und 4 verwendet werden können.


Somit hier Version 0.1:

--------------------------------

ein Monat später:
Die für mich neue Erkenntnis, dass es in einem Velispiel (d.h. der Veli ist der Rechte) keinen 
Guaten gibt erzwingt ein paar Änderungen:

1. In der Klasse Card.java müssen die Methoden zur Bestimmung der nächsten und der vorherigen Karte
angepasst werden. Um diese Änderung aufzuzeigen werden die Methoden umbennant.

public class Card {
	public int color;
	public int number;
	
	public Card(int color, int number) {
		this.color = color;
		this.number = number;
	}
	
	public boolean equals(Card card) {
		return (card.color == this.color && card.number == this.number);
	}
	
	public Card calcGuaterFromRechter() {
		if(this.number == CONSTANTS.SECHSER) return null;
		int newNumber = (this.number + 1) % (CONSTANTS.AS + 1);
		if(newNumber == CONSTANTS.SECHSER) newNumber = CONSTANTS.SIEBNER;
		return new Card(color, newNumber);
	}
	
	public Card calcRechterFromGuater() {
		if(this.number == CONSTANTS.SECHSER) return null;
		int newNumber = (this.number - 1 + CONSTANTS.AS + 1) % (CONSTANTS.AS + 1);
		if(newNumber == CONSTANTS.SECHSER) newNumber = CONSTANTS.AS;
		return new Card(color, newNumber);
	}
	
	public Card nextColorCard() {
		int newColor = this.color;
		newColor = (newColor + 1) % (CONSTANTS.SCHELL + 1);
		return new Card(newColor, number);
	}
}

2. In Result.java muss bei Abfrage nach dem Guaten ebenfalls auf den Veli reagiert werden.

public boolean isGuaterFix() { 
		if(getSchlag() == CONSTANTS.SECHSER) return false;
		return isRechterFix(); 
	}
	
3. Weiters muss in Result.java darauf reagiert werden, dass der Veli keinen evt. Rechten abdeckt!
	
private boolean hasWinnerOrPreviousToWinnerNumber(Card card, Stich lastStich) {
		// hat selbe Number wie der Winner
		if(card.number == lastStich.getWinner().number) return true;
		// alle Fälle, falls mit dem Guatengespielt wird
		if(mitGuatem && lastStich.getWinner().number != CONSTANTS.SECHSER) { 
			if(card.number == lastStich.getWinner().calcRechterFromGuater().number)
				return true;
		} 
		return false;
	}

	
4. Die Testklassen für die jeweiligen Stichetypen Farb- usw. müssen ebenfalls 
noch an den Veli angepast werden.

Dazu wird in BasisStich	die Methode blockVeli eingeführt, die standardmäßig blockiert und nur von 
den Sichklassen Trumpfstich und Rechterstich "nicht blockierend" überschrieben wird.
blockVeli wird dann am Anfang der Strategietemplatemethode runTest aufgerufen.

Da bei einem Trumpfstich mit dem Veli die Farbe nicht bestimmt sein muss, wurde defineTest in 
TrumpfStichTest wie folgt abgewandelt:

protected void defineTest() {
		setKeyCard(getStiche().get(getStiche().size() - 1).getWinner());
		setWinnerNewNumberResult(CONSTANTS.IMPOSSIBLE);
		// s6, e7, h7, s7, 0 wird wegen s7 sclägt s6 nicht als Trumpfstich anerkannt! 
		// Für den Veli wird kein Trumpf gesetzt!
		if(!getStiche().get(getStiche().size() - 1).getWinner().equals(CONSTANTS.VELI))
			setWinnerNewColorResult(CONSTANTS.SURE);
	}
	
Für einen Velistich wird also keine Trumpffarbe gesetzt.

Diese Änderung löst jedoch einen Konflikt in der Konflikterkennung der Methode setUpResult() aus,
da die Abfrage result.getColorAt(keyCard.color) == -winnerNewColorResult für 0 == -0 wahr ergibt 
und setUpResult mit CONSTANTS.IMPOSSIBLE beendet wird.
siehe unten:

private int setUpResult() {
		if((result.getNumberAt(keyCard.number) == -winnerNewNumberResult) || 
		   (result.getColorAt(keyCard.color) == -winnerNewColorResult)) return CONSTANTS.IMPOSSIBLE;
		else {
			result.setNumberAt(keyCard.number,winnerNewNumberResult);
			result.setColorAt(keyCard.color,winnerNewColorResult);
			return CONSTANTS.POSSIBLE;
		}
	}
	
setUpResult wird deshalb wie folgt abgeändert:

private int setUpResult() {
		if(hasStichConfictWithResult()) return CONSTANTS.IMPOSSIBLE;
		else {
			result.setNumberAt(keyCard.number,winnerNewNumberResult);
			result.setColorAt(keyCard.color,winnerNewColorResult);
			return CONSTANTS.POSSIBLE;
		}
	}
	private boolean hasStichConfictWithResult() {
		return (result.getNumberAt(keyCard.number) == -winnerNewNumberResult) 
				|| 
			   ((winnerNewColorResult != 0) && (result.getColorAt(keyCard.color) == -winnerNewColorResult));
	}

In der inzwischen ausgelagerten Abfrage wird das ColorResult nur noch überprüft, wenn es != 0 ist.
winnerNewColorResult ist nur 0, wenn der Veli in eine Trumpfstich auftaucht.